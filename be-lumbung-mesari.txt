Directory structure:
â””â”€â”€ be-lumbung-mesari/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ docker-compose-dev.yml
    â”œâ”€â”€ ingest.py
    â”œâ”€â”€ kysely-ctl.config.ts
    â”œâ”€â”€ nest-cli.json
    â”œâ”€â”€ package.json
    â”œâ”€â”€ tsconfig.build.json
    â”œâ”€â”€ tsconfig.json
    â”œâ”€â”€ .env.example
    â”œâ”€â”€ .eslintrc.js
    â”œâ”€â”€ .prettierrc
    â”œâ”€â”€ docs/
    â”‚   â”œâ”€â”€ requirement.md
    â”‚   â””â”€â”€ decisions/
    â”‚       â””â”€â”€ backend/
    â”‚           â””â”€â”€ 001-use-postgresql.md
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ app.controller.spec.ts
    â”‚   â”œâ”€â”€ app.controller.ts
    â”‚   â”œâ”€â”€ app.module.ts
    â”‚   â”œâ”€â”€ app.service.ts
    â”‚   â”œâ”€â”€ main.ts
    â”‚   â”œâ”€â”€ database/
    â”‚   â”‚   â”œâ”€â”€ base.repository.ts
    â”‚   â”‚   â”œâ”€â”€ database.module.ts
    â”‚   â”‚   â”œâ”€â”€ database.ts
    â”‚   â”‚   â”œâ”€â”€ migrate.ts
    â”‚   â”‚   â”œâ”€â”€ migrations/
    â”‚   â”‚   â”‚   â”œâ”€â”€ 001_initial_schema.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ 002_savings_accounts.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ 003_loans.ts
    â”‚   â”‚   â”‚   â””â”€â”€ 004_audit_notifications.ts
    â”‚   â”‚   â”œâ”€â”€ seeds/
    â”‚   â”‚   â””â”€â”€ types/
    â”‚   â”‚       â”œâ”€â”€ audit.ts
    â”‚   â”‚       â”œâ”€â”€ database.ts
    â”‚   â”‚       â”œâ”€â”€ loans.ts
    â”‚   â”‚       â”œâ”€â”€ roles.ts
    â”‚   â”‚       â”œâ”€â”€ savings.ts
    â”‚   â”‚       â””â”€â”€ users.ts
    â”‚   â”œâ”€â”€ interface/
    â”‚   â”‚   â””â”€â”€ users.ts
    â”‚   â””â”€â”€ users/
    â”‚       â”œâ”€â”€ users.controller.spec.ts
    â”‚       â”œâ”€â”€ users.controller.ts
    â”‚       â”œâ”€â”€ users.module.ts
    â”‚       â”œâ”€â”€ users.service.ts
    â”‚       â””â”€â”€ repositories/
    â”‚           â””â”€â”€ user.repository.ts
    â””â”€â”€ test/
        â”œâ”€â”€ app.e2e-spec.ts
        â””â”€â”€ jest-e2e.json

================================================
File: README.md
================================================
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ npm install
```

## Compile and run the project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil MyÅ›liwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).



================================================
File: docker-compose-dev.yml
================================================
version: '3.8'
services:
  postgres:
    image: postgres:15
    container_name: postgres
    environment:
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: admin123
      POSTGRES_DB: db_lumbung_mesari
    ports:
      - '5432:5432'
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U admin']
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
    driver: local



================================================
File: ingest.py
================================================
from gitingest import ingest
import os

# Get the directory where the script is located
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))

tasks = [
    {
        # Use os.path.join to create absolute path relative to script location
        "source": os.path.join(SCRIPT_DIR),
        "output": os.path.join(SCRIPT_DIR, "be-lumbung-mesari.txt")
    },
]

def ingest_task(task_list=None):
    """
    Process the given tasks or default tasks if none provided
    
    Args:
        task_list (list, optional): List of tasks to process. Each task should be a dict
            with 'source' and 'output' keys. Defaults to None.
    """
    tasks_to_process = task_list if task_list is not None else tasks
    
    for task in tasks_to_process:
        print("Processing task:")
        print(f"  Source: {task['source']}")
        print(f"  Output: {task['output']}")
        
        # Delete the output file if it exists
        if os.path.exists(task["output"]):
            os.remove(task["output"])
            print(f"Deleted existing file: {task['output']}")
        
        # Await the async function call instead of using asyncio.run
        ingest(
            task["source"],
            exclude_patterns={"*.env"},
            output=task["output"]
        )

if __name__ == "__main__":
    # Only run this when script is run directly, not when imported
    ingest_task()


================================================
File: kysely-ctl.config.ts
================================================
import { config } from 'dotenv';
import { resolve } from 'path';

// Load environment variables
config();

const {
  DB_HOST = 'localhost',
  DB_PORT = '5432',
  DB_NAME = 'db_lumbung_mesari',
  DB_USER = 'admin',
  DB_PASSWORD = 'admin123',
} = process.env;

export default {
  // Database connection configuration
  db: {
    host: DB_HOST,
    port: parseInt(DB_PORT, 10),
    database: DB_NAME,
    user: DB_USER,
    password: DB_PASSWORD,
  },
  
  // Migration configuration
  migrationFolder: resolve(__dirname, './src/database/migrations'),
  
  // Migration table name
  migrationTableName: 'kysely_migrations',
};



================================================
File: nest-cli.json
================================================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}



================================================
File: package.json
================================================
{
  "name": "api-lumbung-mesari",
  "private": true,
  "version": "0.0.1",
  "description": "Backend Application for Lumbung Mesari",
  "license": "MIT",
  "engines": {
    "node": "22.x"
  },
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/jest/bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "migrate": "ts-node src/database/migrate.ts",
    "migrate:latest": "npx kysely-ctl --config=kysely-ctl.config.ts migrate --to-latest",
    "migrate:up": "npx kysely-ctl --config=kysely-ctl.config.ts migrate --one-up",
    "migrate:down": "npx kysely-ctl --config=kysely-ctl.config.ts migrate --one-down",
    "migrate:info": "npx kysely-ctl --config=kysely-ctl.config.ts migrate --info"
  },
  "dependencies": {
    "@nestjs/common": "^10.4.15",
    "@nestjs/config": "^4.0.0",
    "@nestjs/core": "^10.4.15",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^10.4.15",
    "@nestjs/schedule": "^5.0.1",
    "@nestjs/swagger": "^8.1.1",
    "@nestjs/throttler": "^6.4.0",
    "bcrypt": "^5.1.1",
    "compression": "^1.8.0",
    "helmet": "^8.0.0",
    "knex": "^3.1.0",
    "kysely": "^0.28.2",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "pg": "^8.16.0",
    "reflect-metadata": "^0.2.0",
    "rxjs": "^7.8.1"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.4.15",
    "@types/bcrypt": "^5.0.2",
    "@types/compression": "^1.7.5",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.2",
    "@types/node": "^20.3.1",
    "@types/passport-jwt": "^4.0.1",
    "@types/pg": "^8.15.2",
    "@types/supertest": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^8.0.0",
    "@typescript-eslint/parser": "^8.0.0",
    "eslint": "^9.20.1",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.7.0",
    "kysely-ctl": "^0.13.1",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
File: tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
File: tsconfig.json
================================================
{
  "compilerOptions": {
    "strict": true,
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  }
}



================================================
File: .env.example
================================================
# Versioning
API_DEFAULT_VERSION=1
API_ENABLED_VERSION=1,2

# Database
DB_HOST=
DB_PORT=
DB_NAME=
DB_USER=
DB_PASSWORD=



================================================
File: .eslintrc.js
================================================
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
  },
};



================================================
File: .prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "none",
  "semi": false
}



================================================
File: docs/requirement.md
================================================
# Lumbung Mesari - Savings and Loans Cooperative System Requirements

## 1. System Overview

The Lumbung Mesari system is a REST API backend service for a savings and loans cooperative. The system will handle member management, savings operations, loan management, and various financial transactions.

## 2. User Management

### 2.1 User Types

- **Administrator**: Manages all cooperative operations
- **Members**: Regular cooperative members who can save and request loans

### 2.2 Authentication & Security

- JWT-based authentication
- Two-Factor Authentication (2FA) via email
- Password Requirements:
  - Minimum 8 characters
  - Must contain numbers
  - Must contain special characters
- Session Management:
  - Auto logout on inactivity
  - Token expiration handling
  - Session tracking

## 3. Member Management

### 3.1 Member Registration

- Required Information:
  - Username
  - Full Name
  - Email
  - Password
  - ID Card Image
  - Selfie Image
- Status tracking (Pending, Approved, Rejected)
- Admin approval workflow
- Email notifications for status changes

### 3.2 Member Profile

- Profile management
- Account status viewing
- Transaction history
- Current balance viewing
- Active loans overview

## 4. Savings Management

### 4.1 Features

- Minimum balance: 100,000 IDR
- Configurable interest rate
- Transaction types:
  - Deposits
  - Withdrawals
- Balance tracking
- Transaction history

### 4.2 Transaction Processing

- Integration with Midtrans payment gateway
  - Bank transfer support
  - E-wallet support
- Transaction status tracking
- Admin approval workflow
- Email notifications

## 5. Loan Management

### 5.1 Loan Features

- Flexible loan amounts (no maximum limit)
- Installment periods:
  - 6 months
  - 12 months
  - 18 months
- Variable interest rates based on duration
- Late payment penalties (0.5% additional interest)

### 5.2 Loan Processing

- Loan application workflow
- Admin approval process
- Installment scheduling
- Automatic installment calculations
- Late payment handling
- Email notifications for:
  - Loan approval/rejection
  - Upcoming payments
  - Late payments

## 6. Reporting System

### 6.1 Member Reports

- Monthly account statements
- Savings balance reports
- Loan status reports
- Payment history

### 6.2 Administrative Reports

- Monthly transaction summaries
- Member status reports
- Loan performance reports
- System audit trails
- Financial statements

## 7. Technical Requirements

### 7.1 Database

- PostgreSQL database
- Implementation of database locking for financial transactions
- Concurrent transaction handling
- Data integrity measures

### 7.2 Performance Requirements

- Support for 70+ concurrent users
- Minimum 18 hours daily uptime
- Optimized query performance
- Caching implementation where appropriate

### 7.3 Backup and Recovery

- Daily automated backups
- Point-in-time recovery capability
- Backup encryption
- Regular backup testing
- Recovery procedures documentation

### 7.4 Security Measures

- Data encryption at rest
- SSL/TLS encryption for data in transit
- Regular security audits
- Input validation
- XSS protection
- SQL injection prevention
- CORS configuration
- Rate limiting

### 7.5 Audit Trail

- Logging of all administrative actions
- Transaction logging
- User activity logging
- System event logging

## 8. Integration Requirements

### 8.1 Payment Gateway

- Midtrans integration
  - Bank transfer implementation
  - E-wallet implementation
- Transaction status synchronization
- Error handling
- Payment reconciliation

### 8.2 Email System

- Transactional email service integration
- Email templates for:
  - Registration confirmation
  - Account approval
  - Transaction notifications
  - Loan notifications
  - Monthly statements
  - 2FA codes

## 9. Non-functional Requirements

### 9.1 Scalability

- Horizontal scaling capability
- Load balancing support
- Database replication support

### 9.2 Maintainability

- Code documentation
- API documentation
- Logging standards
- Error handling standards
- Deployment documentation

### 9.3 Monitoring

- System health monitoring
- Performance monitoring
- Error tracking
- User activity monitoring
- Transaction monitoring

## 10. Development Guidelines

### 10.1 API Standards

- RESTful API design
- JSON response format
- Proper HTTP status codes
- API versioning
- Request/Response validation

### 10.2 Code Quality

- TypeScript/NestJS best practices
- Unit testing requirements
- Integration testing requirements
- Code review process
- Code style guide

## Implementation Phase

Based on the project structure and the implementation roadmap from requirements.md, here's where we stand:

Phase 1: Project Setup & Infrastructure âœ“ (Partially Complete)

- [x] PostgreSQL container setup (docker-compose-dev.yml exists)
- [x] Basic project structure setup (NestJS structure is in place)
- [x] Environment configuration (.gitignore suggests .env usage)
- [x] API Documentation Setup (OpenAPI/Swagger)

Phase 2: Database Design & Setup ðŸš§ (In Progress)

- [ ] Database migrations implementation (Started with users table)
- [ ] Knex query builder setup (knexfile.ts exists)
- [ ] Most of the required tables still need to be created

Phase 3: Authentication & Authorization ðŸš§ (Early Stages)

- [ ] Started users module implementation
- [ ] Most authentication features
- [ ] Two-Factor Authentication
- [ ] Role-based authorization

Phases 4-7: Not Started Yet

- Core Modules Implementation (Savings, Loans, etc.)
- Integration & Features
- Testing & Security
- Documentation & Deployment

Summary of Current State:
The project is in its early stages, primarily in Phase 1 and beginning of Phase 2
Basic infrastructure is set up with:
NestJS framework
PostgreSQL database configuration
Basic project structure
Initial database migration setup
Next immediate steps should be:
Complete the database migrations for all required tables
Implement the authentication system
Set up API documentation with Swagger
Begin implementing core modules (Members, Savings, Loans)



================================================
File: docs/decisions/backend/001-use-postgresql.md
================================================
---
# Configuration for the Jekyll template "Just the Docs"
parent: Decisions
nav_order: 100
title: Use PostgreSQL as Database
# These are optional elements. Feel free to remove any of them.
# status: "{proposed | rejected | accepted | deprecated | â€¦ | superseded by ADR-0123"
# date: {YYYY-MM-DD when the decision was last updated}
# decision-makers: {list everyone involved in the decision}
# consulted: {list everyone whose opinions are sought (typically subject-matter experts); and with whom there is a two-way communication}
# informed: {list everyone who is kept up-to-date on progress; and with whom there is a one-way communication}
---

<!-- we need to disable MD025, because we use the different heading "ADR Template" in the homepage (see above) than it is foreseen in the template -->
<!-- markdownlint-disable-next-line MD025 -->

# PostgreSQL as Database

## Context and Problem Statement

Our application requires a robust, scalable, and feature-rich database management system to handle transactional data and analytical queries. The system must support ACID compliance, advanced querying capabilities, and extensibility while being cost-effective and open-source. This decision evaluates whether PostgreSQL is the best fit for our needs.

## Decision Drivers

- The need for an open-source solution to avoid licensing costs.
- Requirements for ACID compliance to ensure transactional integrity.
- The ability to handle complex queries, including analytical workloads.
- Native support for structured and semi-structured data (e.g., JSONB).
- Community support and ecosystem maturity for extensions and tooling.

## Considered Options

- PostgreSQL
- MySQL
- MongoDB

## Decision Outcome

Chosen option: **PostgreSQL**, because it meets all key requirements, including ACID compliance, rich query capabilities, and support for both structured and semi-structured data. It also has strong community backing and extensibility options.

### Consequences

- **Good**, because PostgreSQL provides advanced features like window functions, full-text search, and JSONB, which streamline development and reduce reliance on external tools.
- **Good**, because it ensures data integrity and supports high concurrency for transactional operations.
- **Bad**, because it may have a steeper learning curve for team members unfamiliar with its advanced features and configurations.

### Confirmation

The decision will be confirmed by implementing a prototype using PostgreSQL and evaluating its performance, reliability, and suitability for the application's needs during the development phase.

## Pros and Cons of the Options

### PostgreSQL

- **Good**, because it supports ACID transactions, ensuring data integrity.
- **Good**, because it has advanced querying capabilities (CTEs, window functions).
- **Good**, because of its support for JSONB, enabling hybrid relational and NoSQL use cases.
- **Neutral**, because it requires more fine-tuning for optimal performance at scale.
- **Bad**, because it has a steeper learning curve for complex configurations.

### MySQL

- **Good**, because it is simple and fast for basic CRUD operations.
- **Good**, because it has broad community support and a familiar syntax.
- **Neutral**, because its JSON support is less robust compared to PostgreSQL.
- **Bad**, because it lacks advanced features like window functions and CTEs.
- **Bad**, because replication and clustering can be less flexible.

### MongoDB

- **Good**, because it excels at handling unstructured data.
- **Good**, because it provides a flexible schema, making it easy to adapt to changing requirements.
- **Neutral**, because it is better suited for NoSQL workloads than transactional use cases.
- **Bad**, because it is not fully ACID-compliant for multi-document transactions.
- **Bad**, because it may require additional effort to integrate with relational data needs.

## More Information

The team will monitor PostgreSQL performance in staging environments and benchmark it against typical use cases. Feedback from database architects and DevOps teams will validate the choice, and adjustments will be made if scalability or performance issues arise. For further details, refer to the PostgreSQL documentation and internal benchmarks.



================================================
File: src/app.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let app: TestingModule;

  beforeAll(async () => {
    app = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();
  });

  describe('getHello', () => {
    it('should return "Hello World!"', () => {
      const appController = app.get(AppController);
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});



================================================
File: src/app.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}



================================================
File: src/app.module.ts
================================================
import { Module } from '@nestjs/common'
import { AppController } from './app.controller'
import { AppService } from './app.service'
import { UsersModule } from './users/users.module'
import { ConfigModule } from '@nestjs/config'
import { DatabaseModule } from './database/database.module'

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env'
    }),
    DatabaseModule,
    UsersModule
  ],
  controllers: [AppController],
  providers: [AppService]
})
export class AppModule {}



================================================
File: src/app.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}



================================================
File: src/main.ts
================================================
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger'
import helmet from 'helmet'
import * as compression from 'compression'
import { VersioningType } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'

async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  const configService = app.get(ConfigService)
  const apiVersion = configService.get<string>('API_DEFAULT_VERSION')
  const enabledVersions = configService.get<string>('API_ENABLED_VERSION')

  // Security middleware
  app.use(helmet())
  app.use(compression())
  app.enableCors()

  // Global prefix
  app.setGlobalPrefix('api')

  // Versioning
  enabledVersions.split(',').forEach((version) => {
    app.enableVersioning({
      type: VersioningType.URI,
      defaultVersion: apiVersion
    })

    // Swagger configuration
    const config = new DocumentBuilder()
      .setTitle('Lumbung Mesari API')
      .setDescription('The Lumbung Mesari API documentation')
      .setVersion(`${version}`)
      .addBearerAuth()
      .build()

    const document = SwaggerModule.createDocument(app, config)
    SwaggerModule.setup(`api/v${version}`, app, document)
  })

  const port = configService.get<number>('PORT', 8000)
  await app.listen(port)
}
bootstrap()



================================================
File: src/database/base.repository.ts
================================================
import { Kysely, Selectable, Insertable, Updateable } from 'kysely';
import { Database } from './types/database';

/**
 * Base repository class that provides common database operations
 * using Kysely for type-safety and performance
 */
export abstract class BaseRepository<T extends keyof Database> {
  protected readonly db: Kysely<Database>;
  protected readonly tableName: T;

  constructor(db: Kysely<Database>, tableName: T) {
    this.db = db;
    this.tableName = tableName;
  }

  /**
   * Find all records with pagination
   */
  async findAll<S extends Selectable<Database[T]>>(
    page = 1, 
    limit = 10
  ): Promise<{ data: S[]; total: number; page: number; limit: number }> {
    const offset = (page - 1) * limit;
    
    const countResult = await this.db
      .selectFrom(this.tableName)
      .select(this.db.fn.count<number>('id').as('count'))
      .executeTakeFirstOrThrow();
      
    const data = await this.db
      .selectFrom(this.tableName)
      .selectAll()
      .limit(limit)
      .offset(offset)
      .execute() as S[];
    
    return {
      data,
      total: Number(countResult.count),
      page,
      limit
    };
  }

  /**
   * Find record by ID
   */
  async findById<S extends Selectable<Database[T]>>(id: string): Promise<S | undefined> {
    return this.db
      .selectFrom(this.tableName)
      .selectAll()
      .where('id', '=', id)
      .executeTakeFirst() as Promise<S | undefined>;
  }

  /**
   * Create a new record
   */
  async create<I extends Insertable<Database[T]>, S extends Selectable<Database[T]>>(
    data: I
  ): Promise<S> {
    return this.db
      .insertInto(this.tableName)
      .values(data)
      .returningAll()
      .executeTakeFirstOrThrow() as Promise<S>;
  }

  /**
   * Update a record
   */
  async update<U extends Updateable<Database[T]>, S extends Selectable<Database[T]>>(
    id: string, 
    data: U
  ): Promise<S> {
    return this.db
      .updateTable(this.tableName)
      .set(data)
      .where('id', '=', id)
      .returningAll()
      .executeTakeFirstOrThrow() as Promise<S>;
  }

  /**
   * Delete a record
   */
  async delete<S extends Selectable<Database[T]>>(id: string): Promise<S> {
    return this.db
      .deleteFrom(this.tableName)
      .where('id', '=', id)
      .returningAll()
      .executeTakeFirstOrThrow() as Promise<S>;
  }
}



================================================
File: src/database/database.module.ts
================================================
import { Module, Global } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { db } from './database';

@Global()
@Module({
  imports: [ConfigModule],
  providers: [
    {
      provide: 'DATABASE',
      useValue: db,
    },
  ],
  exports: ['DATABASE'],
})
export class DatabaseModule {}



================================================
File: src/database/database.ts
================================================
import { Database } from './types/database'
import { Pool } from 'pg'
import { Kysely, PostgresDialect } from 'kysely'
import { config } from 'dotenv'

// Load environment variables
config()

const { 
  DB_HOST = 'localhost',
  DB_PORT = '5432',
  DB_NAME = 'db_lumbung_mesari',
  DB_USER = 'admin',
  DB_PASSWORD = 'admin123'
} = process.env

const dialect = new PostgresDialect({
  pool: new Pool({
    database: DB_NAME,
    host: DB_HOST,
    user: DB_USER,
    password: DB_PASSWORD,
    port: parseInt(DB_PORT || '5432', 10),
    max: 10
  })
})

// Database interface is passed to Kysely's constructor, and from now on, Kysely
// knows your database structure.
// Dialect is passed to Kysely's constructor, and from now on, Kysely knows how
// to communicate with your database.
export const db = new Kysely<Database>({
  dialect
})



================================================
File: src/database/migrate.ts
================================================
import { promises as fs } from 'fs';
import { resolve } from 'path';
import { FileMigrationProvider, Kysely, Migrator, PostgresDialect } from 'kysely';
import { Pool } from 'pg';
import { config } from 'dotenv';

// Load environment variables
config();

const {
  DB_HOST = 'localhost',
  DB_PORT = '5432',
  DB_NAME = 'db_lumbung_mesari',
  DB_USER = 'admin',
  DB_PASSWORD = 'admin123',
} = process.env;

async function migrateToLatest() {
  // Database connection
  const db = new Kysely({
    dialect: new PostgresDialect({
      pool: new Pool({
        host: DB_HOST,
        port: parseInt(DB_PORT, 10),
        database: DB_NAME,
        user: DB_USER,
        password: DB_PASSWORD,
      }),
    }),
  });

  // Migrator
  const migrator = new Migrator({
    db,
    provider: new FileMigrationProvider({
      fs,
      path: resolve(__dirname, 'migrations'),
    }),
  });

  const { error, results } = await migrator.migrateToLatest();

  // Close the connection
  await db.destroy();

  if (error) {
    console.error('Migration failed:');
    console.error(error);
    process.exit(1);
  }

  if (results && results.length > 0) {
    console.log('Migrations completed:');
    results.forEach((migration) => {
      console.log(`- ${migration.migrationName}: ${migration.status}`);
    });
  } else {
    console.log('No migrations to run - database is up to date');
  }
}

// Run the migration
migrateToLatest().catch((error) => {
  console.error('Migration error:');
  console.error(error);
  process.exit(1);
});



================================================
File: src/database/migrations/001_initial_schema.ts
================================================
import { Kysely, sql } from 'kysely';

export async function up(db: Kysely<any>): Promise<void> {
  // Create roles table
  await db.schema
    .createTable('roles')
    .addColumn('id', 'uuid', (col) => 
      col.primaryKey().defaultTo(sql`gen_random_uuid()`)
    )
    .addColumn('name', 'varchar', (col) => 
      col.notNull().unique()
    )
    .addColumn('created_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .addColumn('updated_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .execute();

  // Create users table
  await db.schema
    .createTable('users')
    .addColumn('id', 'uuid', (col) => 
      col.primaryKey().defaultTo(sql`gen_random_uuid()`)
    )
    .addColumn('email', 'varchar', (col) => 
      col.notNull().unique()
    )
    .addColumn('fullname', 'varchar', (col) => 
      col.notNull()
    )
    .addColumn('username', 'varchar', (col) => 
      col.notNull().unique()
    )
    .addColumn('password', 'varchar', (col) => 
      col.notNull()
    )
    .addColumn('phone_number', 'varchar', (col) => 
      col.notNull()
    )
    .addColumn('address', 'text', (col) => 
      col.notNull()
    )
    .addColumn('status', 'varchar', (col) => 
      col.notNull().defaultTo('pending')
    )
    .addColumn('role_id', 'uuid', (col) => 
      col.references('roles.id').onDelete('restrict').notNull()
    )
    .addColumn('id_card_image', 'varchar', (col) => 
      col.notNull()
    )
    .addColumn('selfie_image', 'varchar', (col) => 
      col.notNull()
    )
    .addColumn('created_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .addColumn('updated_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .execute();

  // Insert default roles
  await db
    .insertInto('roles')
    .values([
      { name: 'administrator' },
      { name: 'member' }
    ])
    .execute();
}

export async function down(db: Kysely<any>): Promise<void> {
  // Drop tables in reverse order
  await db.schema.dropTable('users').execute();
  await db.schema.dropTable('roles').execute();
}



================================================
File: src/database/migrations/002_savings_accounts.ts
================================================
import { Kysely, sql } from 'kysely';

export async function up(db: Kysely<any>): Promise<void> {
  // Create savings_accounts table
  await db.schema
    .createTable('savings_accounts')
    .addColumn('id', 'uuid', (col) => 
      col.primaryKey().defaultTo(sql`gen_random_uuid()`)
    )
    .addColumn('user_id', 'uuid', (col) => 
      col.references('users.id').onDelete('cascade').notNull()
    )
    .addColumn('account_number', 'varchar', (col) => 
      col.notNull().unique()
    )
    .addColumn('balance', 'decimal(15, 2)', (col) => 
      col.notNull().defaultTo('0.00')
    )
    .addColumn('interest_rate', 'decimal(5, 2)', (col) => 
      col.notNull().defaultTo('0.00')
    )
    .addColumn('status', 'varchar', (col) => 
      col.notNull().defaultTo('active')
    )
    .addColumn('created_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .addColumn('updated_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .execute();

  // Create transaction_types table
  await db.schema
    .createTable('transaction_types')
    .addColumn('id', 'uuid', (col) => 
      col.primaryKey().defaultTo(sql`gen_random_uuid()`)
    )
    .addColumn('name', 'varchar', (col) => 
      col.notNull().unique()
    )
    .addColumn('description', 'text')
    .addColumn('created_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .addColumn('updated_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .execute();

  // Create transactions table
  await db.schema
    .createTable('transactions')
    .addColumn('id', 'uuid', (col) => 
      col.primaryKey().defaultTo(sql`gen_random_uuid()`)
    )
    .addColumn('savings_account_id', 'uuid', (col) => 
      col.references('savings_accounts.id').onDelete('restrict').notNull()
    )
    .addColumn('transaction_type_id', 'uuid', (col) => 
      col.references('transaction_types.id').onDelete('restrict').notNull()
    )
    .addColumn('amount', 'decimal(15, 2)', (col) => 
      col.notNull()
    )
    .addColumn('description', 'text')
    .addColumn('reference_number', 'varchar', (col) => 
      col.notNull().unique()
    )
    .addColumn('status', 'varchar', (col) => 
      col.notNull().defaultTo('pending')
    )
    .addColumn('payment_method', 'varchar')
    .addColumn('payment_details', 'jsonb')
    .addColumn('created_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .addColumn('updated_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .execute();

  // Insert default transaction types
  await db
    .insertInto('transaction_types')
    .values([
      { name: 'deposit', description: 'Deposit into savings account' },
      { name: 'withdrawal', description: 'Withdrawal from savings account' },
      { name: 'interest', description: 'Interest earned on savings' },
      { name: 'fee', description: 'Fee charged on account' }
    ])
    .execute();
}

export async function down(db: Kysely<any>): Promise<void> {
  // Drop tables in reverse order
  await db.schema.dropTable('transactions').execute();
  await db.schema.dropTable('transaction_types').execute();
  await db.schema.dropTable('savings_accounts').execute();
}



================================================
File: src/database/migrations/003_loans.ts
================================================
import { Kysely, sql } from 'kysely';

export async function up(db: Kysely<any>): Promise<void> {
  // Create loan_periods table
  await db.schema
    .createTable('loan_periods')
    .addColumn('id', 'uuid', (col) => 
      col.primaryKey().defaultTo(sql`gen_random_uuid()`)
    )
    .addColumn('months', 'integer', (col) => 
      col.notNull().unique()
    )
    .addColumn('interest_rate', 'decimal(5, 2)', (col) => 
      col.notNull()
    )
    .addColumn('created_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .addColumn('updated_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .execute();

  // Create loans table
  await db.schema
    .createTable('loans')
    .addColumn('id', 'uuid', (col) => 
      col.primaryKey().defaultTo(sql`gen_random_uuid()`)
    )
    .addColumn('user_id', 'uuid', (col) => 
      col.references('users.id').onDelete('restrict').notNull()
    )
    .addColumn('loan_number', 'varchar', (col) => 
      col.notNull().unique()
    )
    .addColumn('amount', 'decimal(15, 2)', (col) => 
      col.notNull()
    )
    .addColumn('loan_period_id', 'uuid', (col) => 
      col.references('loan_periods.id').onDelete('restrict').notNull()
    )
    .addColumn('interest_rate', 'decimal(5, 2)', (col) => 
      col.notNull()
    )
    .addColumn('total_amount', 'decimal(15, 2)', (col) => 
      col.notNull()
    )
    .addColumn('monthly_payment', 'decimal(15, 2)', (col) => 
      col.notNull()
    )
    .addColumn('start_date', 'date')
    .addColumn('end_date', 'date')
    .addColumn('purpose', 'text', (col) => 
      col.notNull()
    )
    .addColumn('status', 'varchar', (col) => 
      col.notNull().defaultTo('pending')
    )
    .addColumn('created_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .addColumn('updated_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .execute();

  // Create installments table
  await db.schema
    .createTable('installments')
    .addColumn('id', 'uuid', (col) => 
      col.primaryKey().defaultTo(sql`gen_random_uuid()`)
    )
    .addColumn('loan_id', 'uuid', (col) => 
      col.references('loans.id').onDelete('cascade').notNull()
    )
    .addColumn('installment_number', 'integer', (col) => 
      col.notNull()
    )
    .addColumn('due_date', 'date', (col) => 
      col.notNull()
    )
    .addColumn('amount', 'decimal(15, 2)', (col) => 
      col.notNull()
    )
    .addColumn('principal_amount', 'decimal(15, 2)', (col) => 
      col.notNull()
    )
    .addColumn('interest_amount', 'decimal(15, 2)', (col) => 
      col.notNull()
    )
    .addColumn('penalty_amount', 'decimal(15, 2)', (col) => 
      col.notNull().defaultTo('0.00')
    )
    .addColumn('paid_amount', 'decimal(15, 2)', (col) => 
      col.notNull().defaultTo('0.00')
    )
    .addColumn('paid_date', 'date')
    .addColumn('status', 'varchar', (col) => 
      col.notNull().defaultTo('pending')
    )
    .addColumn('payment_transaction_id', 'uuid', (col) => 
      col.references('transactions.id').onDelete('set null')
    )
    .addColumn('created_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .addColumn('updated_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .execute();

  // Insert default loan periods with their interest rates
  await db
    .insertInto('loan_periods')
    .values([
      { months: 6, interest_rate: 5.00 },
      { months: 12, interest_rate: 7.50 },
      { months: 18, interest_rate: 10.00 }
    ])
    .execute();
}

export async function down(db: Kysely<any>): Promise<void> {
  // Drop tables in reverse order
  await db.schema.dropTable('installments').execute();
  await db.schema.dropTable('loans').execute();
  await db.schema.dropTable('loan_periods').execute();
}



================================================
File: src/database/migrations/004_audit_notifications.ts
================================================
import { Kysely, sql } from 'kysely';

export async function up(db: Kysely<any>): Promise<void> {
  // Create audit_logs table for tracking all administrative actions
  await db.schema
    .createTable('audit_logs')
    .addColumn('id', 'uuid', (col) => 
      col.primaryKey().defaultTo(sql`gen_random_uuid()`)
    )
    .addColumn('user_id', 'uuid', (col) => 
      col.references('users.id').onDelete('set null')
    )
    .addColumn('action', 'varchar', (col) => 
      col.notNull()
    )
    .addColumn('entity_type', 'varchar', (col) => 
      col.notNull()
    )
    .addColumn('entity_id', 'varchar', (col) => 
      col.notNull()
    )
    .addColumn('old_values', 'jsonb')
    .addColumn('new_values', 'jsonb')
    .addColumn('ip_address', 'varchar')
    .addColumn('user_agent', 'varchar')
    .addColumn('created_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .execute();

  // Create notification_types table
  await db.schema
    .createTable('notification_types')
    .addColumn('id', 'uuid', (col) => 
      col.primaryKey().defaultTo(sql`gen_random_uuid()`)
    )
    .addColumn('name', 'varchar', (col) => 
      col.notNull().unique()
    )
    .addColumn('description', 'text')
    .addColumn('template', 'text', (col) => 
      col.notNull()
    )
    .addColumn('created_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .addColumn('updated_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .execute();

  // Create notifications table
  await db.schema
    .createTable('notifications')
    .addColumn('id', 'uuid', (col) => 
      col.primaryKey().defaultTo(sql`gen_random_uuid()`)
    )
    .addColumn('user_id', 'uuid', (col) => 
      col.references('users.id').onDelete('cascade').notNull()
    )
    .addColumn('notification_type_id', 'uuid', (col) => 
      col.references('notification_types.id').onDelete('restrict').notNull()
    )
    .addColumn('title', 'varchar', (col) => 
      col.notNull()
    )
    .addColumn('message', 'text', (col) => 
      col.notNull()
    )
    .addColumn('data', 'jsonb')
    .addColumn('is_read', 'boolean', (col) => 
      col.notNull().defaultTo(false)
    )
    .addColumn('read_at', 'timestamp')
    .addColumn('created_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .addColumn('updated_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .execute();

  // Create email_logs table for tracking all sent emails
  await db.schema
    .createTable('email_logs')
    .addColumn('id', 'uuid', (col) => 
      col.primaryKey().defaultTo(sql`gen_random_uuid()`)
    )
    .addColumn('user_id', 'uuid', (col) => 
      col.references('users.id').onDelete('set null')
    )
    .addColumn('email', 'varchar', (col) => 
      col.notNull()
    )
    .addColumn('subject', 'varchar', (col) => 
      col.notNull()
    )
    .addColumn('body', 'text', (col) => 
      col.notNull()
    )
    .addColumn('status', 'varchar', (col) => 
      col.notNull()
    )
    .addColumn('error', 'text')
    .addColumn('created_at', 'timestamp', (col) => 
      col.notNull().defaultTo(sql`now()`)
    )
    .execute();

  // Insert default notification types
  await db
    .insertInto('notification_types')
    .values([
      { 
        name: 'account_approval', 
        description: 'Account approval notification',
        template: 'Your account has been approved. You can now access all features.'
      },
      { 
        name: 'transaction_confirmation', 
        description: 'Transaction confirmation notification',
        template: 'Your transaction of {{amount}} has been {{status}}.'
      },
      { 
        name: 'loan_approval', 
        description: 'Loan approval notification',
        template: 'Your loan application for {{amount}} has been {{status}}.'
      },
      { 
        name: 'payment_reminder', 
        description: 'Payment reminder notification',
        template: 'Reminder: Your loan payment of {{amount}} is due on {{due_date}}.'
      },
      { 
        name: 'late_payment', 
        description: 'Late payment notification',
        template: 'Your loan payment of {{amount}} was due on {{due_date}} and is now overdue.'
      }
    ])
    .execute();
}

export async function down(db: Kysely<any>): Promise<void> {
  // Drop tables in reverse order
  await db.schema.dropTable('email_logs').execute();
  await db.schema.dropTable('notifications').execute();
  await db.schema.dropTable('notification_types').execute();
  await db.schema.dropTable('audit_logs').execute();
}




================================================
File: src/database/types/audit.ts
================================================
import { Selectable, Insertable, Updateable, Generated } from 'kysely'

export interface AuditLogTable {
  id: Generated<string>
  user_id: string | null
  action: string
  entity_type: string
  entity_id: string
  old_values: unknown | null
  new_values: unknown | null
  ip_address: string | null
  user_agent: string | null
  created_at: Generated<Date>
}

export interface NotificationTypeTable {
  id: Generated<string>
  name: string
  description: string | null
  template: string
  created_at: Generated<Date>
  updated_at: Generated<Date>
}

export interface NotificationTable {
  id: Generated<string>
  user_id: string
  notification_type_id: string
  title: string
  message: string
  data: unknown | null
  is_read: boolean
  read_at: Date | null
  created_at: Generated<Date>
  updated_at: Generated<Date>
}

export interface EmailLogTable {
  id: Generated<string>
  user_id: string | null
  email: string
  subject: string
  body: string
  status: string
  error: string | null
  created_at: Generated<Date>
}

export type AuditLog = Selectable<AuditLogTable>
export type NewAuditLog = Insertable<AuditLogTable>
export type UpdateAuditLog = Updateable<AuditLogTable>

export type NotificationType = Selectable<NotificationTypeTable>
export type NewNotificationType = Insertable<NotificationTypeTable>
export type UpdateNotificationType = Updateable<NotificationTypeTable>

export type Notification = Selectable<NotificationTable>
export type NewNotification = Insertable<NotificationTable>
export type UpdateNotification = Updateable<NotificationTable>

export type EmailLog = Selectable<EmailLogTable>
export type NewEmailLog = Insertable<EmailLogTable>
export type UpdateEmailLog = Updateable<EmailLogTable>



================================================
File: src/database/types/database.ts
================================================
import { UserTable } from './users'
import { RoleTable } from './roles'
import { SavingsAccountTable, TransactionTable, TransactionTypeTable } from './savings'
import { LoanTable, LoanPeriodTable, InstallmentTable } from './loans'
import { AuditLogTable, NotificationTable, NotificationTypeTable, EmailLogTable } from './audit'

export interface Database {
  // User management
  users: UserTable
  roles: RoleTable
  
  // Savings management
  savings_accounts: SavingsAccountTable
  transaction_types: TransactionTypeTable
  transactions: TransactionTable
  
  // Loan management
  loan_periods: LoanPeriodTable
  loans: LoanTable
  installments: InstallmentTable
  
  // Audit and notifications
  audit_logs: AuditLogTable
  notification_types: NotificationTypeTable
  notifications: NotificationTable
  email_logs: EmailLogTable
}



================================================
File: src/database/types/loans.ts
================================================
import { Selectable, Insertable, Updateable, Generated } from 'kysely'

export interface LoanPeriodTable {
  id: Generated<string>
  months: number
  interest_rate: string
  created_at: Generated<Date>
  updated_at: Generated<Date>
}

export interface LoanTable {
  id: Generated<string>
  user_id: string
  loan_number: string
  amount: string
  loan_period_id: string
  interest_rate: string
  total_amount: string
  monthly_payment: string
  start_date: Date | null
  end_date: Date | null
  purpose: string
  status: string
  created_at: Generated<Date>
  updated_at: Generated<Date>
}

export interface InstallmentTable {
  id: Generated<string>
  loan_id: string
  installment_number: number
  due_date: Date
  amount: string
  principal_amount: string
  interest_amount: string
  penalty_amount: string
  paid_amount: string
  paid_date: Date | null
  status: string
  payment_transaction_id: string | null
  created_at: Generated<Date>
  updated_at: Generated<Date>
}

export type LoanPeriod = Selectable<LoanPeriodTable>
export type NewLoanPeriod = Insertable<LoanPeriodTable>
export type UpdateLoanPeriod = Updateable<LoanPeriodTable>

export type Loan = Selectable<LoanTable>
export type NewLoan = Insertable<LoanTable>
export type UpdateLoan = Updateable<LoanTable>

export type Installment = Selectable<InstallmentTable>
export type NewInstallment = Insertable<InstallmentTable>
export type UpdateInstallment = Updateable<InstallmentTable>



================================================
File: src/database/types/roles.ts
================================================
import { Selectable, Insertable, Updateable, Generated } from 'kysely'

export interface RoleTable {
  id: Generated<string>
  name: string
  created_at: Generated<Date>
  updated_at: Generated<Date>
}
export type Role = Selectable<RoleTable>
export type NewRole = Insertable<RoleTable>
export type UpdateRole = Updateable<RoleTable>



================================================
File: src/database/types/savings.ts
================================================
import { Selectable, Insertable, Updateable, Generated } from 'kysely'

export interface SavingsAccountTable {
  id: Generated<string>
  user_id: string
  account_number: string
  balance: string
  interest_rate: string
  status: string
  created_at: Generated<Date>
  updated_at: Generated<Date>
}

export interface TransactionTypeTable {
  id: Generated<string>
  name: string
  description: string | null
  created_at: Generated<Date>
  updated_at: Generated<Date>
}

export interface TransactionTable {
  id: Generated<string>
  savings_account_id: string
  transaction_type_id: string
  amount: string
  description: string | null
  reference_number: string
  status: string
  payment_method: string | null
  payment_details: unknown | null
  created_at: Generated<Date>
  updated_at: Generated<Date>
}

export type SavingsAccount = Selectable<SavingsAccountTable>
export type NewSavingsAccount = Insertable<SavingsAccountTable>
export type UpdateSavingsAccount = Updateable<SavingsAccountTable>

export type TransactionType = Selectable<TransactionTypeTable>
export type NewTransactionType = Insertable<TransactionTypeTable>
export type UpdateTransactionType = Updateable<TransactionTypeTable>

export type Transaction = Selectable<TransactionTable>
export type NewTransaction = Insertable<TransactionTable>
export type UpdateTransaction = Updateable<TransactionTable>



================================================
File: src/database/types/users.ts
================================================
import { Selectable, Insertable, Updateable, Generated } from 'kysely'

export interface UserTable {
  id: Generated<string>
  email: string
  fullname: string
  username: string
  password: string
  phone_number: string
  address: string
  status: string
  role_id: string
  id_card_image: string
  selfie_image: string
  created_at: Generated<Date>
  updated_at: Generated<Date>
}
export type User = Selectable<UserTable>
export type NewUser = Insertable<UserTable>
export type UpdateUser = Updateable<UserTable>



================================================
File: src/interface/users.ts
================================================
export type User = {
  id: number
  name: string
}



================================================
File: src/users/users.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing'
import { UsersController } from './users.controller'
import { UsersService } from './users.service'

describe('UsersController', () => {
  let controller: UsersController

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [UsersController],
      providers: [UsersService]
    }).compile()

    controller = module.get<UsersController>(UsersController)
  })

  it('should be defined', () => {
    expect(controller).toBeDefined()
  })

  it('should return all users', async () => {
    const result = await controller.findAllV1()
    expect(result).toBe('Hello World')
  })
})



================================================
File: src/users/users.controller.ts
================================================
import {
  Controller,
  Get,
  Inject,
  Version,
  VERSION_NEUTRAL
} from '@nestjs/common'
import { UsersService } from './users.service'

@Controller('/users')
export class UsersController {
  @Inject()
  private readonly usersService: UsersService

  @Version(VERSION_NEUTRAL)
  @Get()
  async findAllNeutral() {
    return this.findAllV1()
  }

  @Version('1')
  @Get()
  async findAllV1() {
    return this.usersService.findAll()
  }

  @Version('2')
  @Get()
  async findAllV2() {
    return this.usersService.findAll()
  }
}



================================================
File: src/users/users.module.ts
================================================
import { Module } from '@nestjs/common'
import { UsersController } from './users.controller'
import { UsersService } from './users.service'

@Module({
  controllers: [UsersController],
  providers: [UsersService]
})
export class UsersModule {}



================================================
File: src/users/users.service.ts
================================================
import { Injectable } from '@nestjs/common'
import { User } from 'src/interface/users'

@Injectable()
export class UsersService {
  private readonly users = [
    { id: 1, name: 'John Doe' },
    { id: 2, name: 'Jane Doe' }
  ]

  create(user: User) {
    this.users.push(user)
  }

  findAll(): User[] {
    return this.users
  }
}



================================================
File: src/users/repositories/user.repository.ts
================================================
import { Injectable, Inject } from '@nestjs/common';
import { Kysely } from 'kysely';
import { Database } from '../../database/types/database';
import { BaseRepository } from '../../database/base.repository';
import { User, NewUser, UpdateUser } from '../../database/types/users';

@Injectable()
export class UserRepository extends BaseRepository<'users'> {
  constructor(@Inject('DATABASE') protected readonly db: Kysely<Database>) {
    super(db, 'users');
  }

  /**
   * Find user by email
   */
  async findByEmail(email: string): Promise<User | undefined> {
    return this.db
      .selectFrom('users')
      .selectAll()
      .where('email', '=', email)
      .executeTakeFirst() as Promise<User | undefined>;
  }

  /**
   * Find user by username
   */
  async findByUsername(username: string): Promise<User | undefined> {
    return this.db
      .selectFrom('users')
      .selectAll()
      .where('username', '=', username)
      .executeTakeFirst() as Promise<User | undefined>;
  }
  
  /**
   * Find users with role information
   */
  async findAllWithRoles(page = 1, limit = 10): Promise<{ data: (User & { role_name: string })[]; total: number; page: number; limit: number }> {
    const offset = (page - 1) * limit;
    
    // Get total count
    const countResult = await this.db
      .selectFrom('users')
      .select(this.db.fn.count<number>('id').as('count'))
      .executeTakeFirstOrThrow();
      
    // Get users with role information
    const data = await this.db
      .selectFrom('users')
      .innerJoin('roles', 'roles.id', 'users.role_id')
      .select([
        'users.id',
        'users.email',
        'users.fullname',
        'users.username',
        'users.phone_number',
        'users.address',
        'users.status',
        'users.role_id',
        'users.created_at',
        'users.updated_at',
        'roles.name as role_name'
      ])
      .limit(limit)
      .offset(offset)
      .execute() as (User & { role_name: string })[];
    
    return {
      data,
      total: Number(countResult.count),
      page,
      limit
    };
  }

  /**
   * Create a new user
   */
  async createUser(data: NewUser): Promise<User> {
    return this.create<NewUser, User>(data);
  }

  /**
   * Update a user
   */
  async updateUser(id: string, data: UpdateUser): Promise<User> {
    return this.update<UpdateUser, User>(id, data);
  }

  /**
   * Update user status
   */
  async updateStatus(id: string, status: string): Promise<User> {
    return this.update<UpdateUser, User>(id, { status } as UpdateUser);
  }
}



================================================
File: test/app.e2e-spec.ts
================================================
import * as request from 'supertest';
import { Test } from '@nestjs/testing';
import { AppModule } from './../src/app.module';
import { INestApplication } from '@nestjs/common';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});



================================================
File: test/jest-e2e.json
================================================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": "\\.e2e-spec\\.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}


