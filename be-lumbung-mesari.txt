Directory structure:
└── src/
    ├── app.controller.spec.ts
    ├── app.controller.ts
    ├── app.module.ts
    ├── app.service.ts
    ├── main.ts
    ├── auth/
    │   ├── auth.controller.ts
    │   ├── auth.module.ts
    │   ├── auth.service.ts
    │   ├── decorators/
    │   │   ├── current-user.decorator.ts
    │   │   └── roles.decorator.ts
    │   ├── dto/
    │   │   ├── login.dto.ts
    │   │   └── register.dto.ts
    │   ├── enums/
    │   │   └── role.enum.ts
    │   ├── guards/
    │   │   ├── auth.guard.ts
    │   │   └── roles.guard.ts
    │   └── strategies/
    │       └── jwt.strategy.ts
    ├── database/
    │   ├── base.repository.ts
    │   ├── database.config.ts
    │   ├── database.module.ts
    │   ├── database.service.ts
    │   ├── migrations/
    │   │   ├── 20250531154634_create_roles_table.ts
    │   │   ├── 20250531160815_create_users_table.ts
    │   │   └── 20250531163446_create_notifications_audit_related_table.ts
    │   ├── seeds/
    │   │   ├── 001_roles.ts
    │   │   └── 002_admin_user.ts
    │   └── types/
    │       ├── audit.ts
    │       ├── database.ts
    │       ├── loans.ts
    │       ├── roles.ts
    │       ├── savings.ts
    │       └── users.ts
    ├── interface/
    │   ├── jwt.ts
    │   └── users.ts
    └── users/
        ├── users.controller.spec.ts
        ├── users.controller.ts
        ├── users.module.ts
        ├── users.repository.ts
        └── users.service.ts

================================================
FILE: app.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let app: TestingModule;

  beforeAll(async () => {
    app = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();
  });

  describe('getHello', () => {
    it('should return "Hello World!"', () => {
      const appController = app.get(AppController);
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});



================================================
FILE: app.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}



================================================
FILE: app.module.ts
================================================
import { Module } from '@nestjs/common'
import { AppController } from './app.controller'
import { AppService } from './app.service'
import { UsersModule } from './users/users.module'
import { ConfigModule } from '@nestjs/config'
import { AuthModule } from './auth/auth.module'

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env'
    }),
    UsersModule,
    AuthModule
  ],
  controllers: [AppController],
  providers: [AppService]
})
export class AppModule {}



================================================
FILE: app.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}



================================================
FILE: main.ts
================================================
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger'
import helmet from 'helmet'
import * as compression from 'compression'
import { VersioningType } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'

async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  const configService = app.get(ConfigService)
  const apiVersion = configService.get<string>('API_DEFAULT_VERSION')
  const enabledVersions = configService.get<string>('API_ENABLED_VERSION')

  // Security middleware
  app.use(helmet())
  app.use(compression())
  app.enableCors()

  // Global prefix
  app.setGlobalPrefix('api')

  // Versioning
  enabledVersions?.split(',').forEach((version) => {
    app.enableVersioning({
      type: VersioningType.URI,
      defaultVersion: apiVersion
    })

    // Swagger configuration
    const config = new DocumentBuilder()
      .setTitle('Lumbung Mesari API')
      .setDescription('The Lumbung Mesari API documentation')
      .setVersion(`${version}`)
      .addBearerAuth()
      .build()

    const document = SwaggerModule.createDocument(app, config)
    SwaggerModule.setup(`api/v${version}`, app, document)
  })

  const port = configService.get<number>('PORT', 8000)
  await app.listen(port)
}
bootstrap()



================================================
FILE: auth/auth.controller.ts
================================================
import { Body, Controller, Post, UseGuards, Request, Get } from '@nestjs/common'
import { AuthGuard } from '@nestjs/passport'
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger'
import { AuthService } from './auth.service'
import { LoginDto } from './dto/login.dto'
import { RegisterDto } from './dto/register.dto'
import { JwtAuthGuard } from './guards/auth.guard'
import { Roles } from './decorators/roles.decorator'
import { RolesGuard } from './guards/roles.guard'
import { UserRole } from './enums/role.enum'
import { CurrentUser } from './decorators/current-user.decorator'

@ApiTags('auth')
@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('login')
  @ApiOperation({ summary: 'User login' })
  @ApiResponse({ status: 201, description: 'Successfully logged in' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  async login(@Body() loginDto: LoginDto) {
    return this.authService.login(loginDto)
  }

  @Post('register')
  @ApiOperation({ summary: 'Register a new user' })
  @ApiResponse({ status: 201, description: 'User registered successfully' })
  @ApiResponse({ status: 400, description: 'Bad request' })
  async register(@Body() registerDto: RegisterDto) {
    return this.authService.register(registerDto)
  }

  @UseGuards(JwtAuthGuard)
  @Post('refresh')
  @ApiOperation({ summary: 'Refresh access token' })
  @ApiResponse({ status: 201, description: 'Token refreshed' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  async refresh(@Request() req: { user: any }) {
    return this.authService.refreshToken(req.user)
  }

  @Get('profile')
  @ApiOperation({ summary: 'Get user profile' })
  @ApiResponse({ status: 200, description: 'Profile retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  getProfile(@CurrentUser() user: any) {
    return user
  }

  @UseGuards(RolesGuard, JwtAuthGuard)
  @Roles(UserRole.ADMIN)
  @Get('admin')
  @ApiOperation({ summary: 'Admin only endpoint' })
  @ApiResponse({
    status: 200,
    description: 'Admin data retrieved successfully'
  })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({
    status: 403,
    description: 'Forbidden - Insufficient permissions'
  })
  getAdminData(@CurrentUser() user: any) {
    return {
      message: 'This is admin only data',
      user
    }
  }
}



================================================
FILE: auth/auth.module.ts
================================================
import { Module } from '@nestjs/common'
import { JwtModule } from '@nestjs/jwt'
import { PassportModule } from '@nestjs/passport'
import { ConfigModule, ConfigService } from '@nestjs/config'
import { UsersModule } from '../users/users.module'
import { AuthService } from './auth.service'
import { AuthController } from './auth.controller'
import { JwtStrategy } from './strategies/jwt.strategy'

@Module({
  imports: [
    UsersModule,
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>(
          'JWT_SECRET',
          'your-default-secret-key'
        ),
        signOptions: {
          expiresIn: configService.get<string>('JWT_EXPIRES_IN', '1h')
        }
      }),
      inject: [ConfigService]
    })
  ],
  providers: [AuthService, JwtStrategy],
  controllers: [AuthController],
  exports: [AuthService]
})
export class AuthModule {}



================================================
FILE: auth/auth.service.ts
================================================
import { Injectable, UnauthorizedException } from '@nestjs/common'
import { JwtService } from '@nestjs/jwt'
import { compare, hash } from 'bcrypt'
import { UsersService } from '../users/users.service'
import { LoginDto } from './dto/login.dto'
import { RegisterDto } from './dto/register.dto'
import { JwtPayload } from '../interface/jwt'

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService
  ) {}

  async validateUser(email: string, password: string): Promise<any> {
    const user = await this.usersService.findByEmailWithRole(email)
    if (user && (await compare(password, user.password))) {
      const { password, ...result } = user
      return result
    }
    return null
  }

  async login(loginDto: LoginDto) {
    const user = await this.validateUser(loginDto.email, loginDto.password)
    if (!user) {
      throw new UnauthorizedException('Invalid credentials')
    }
    return this.generateTokens(user)
  }

  async register(registerDto: RegisterDto) {
    const hashedPassword = await hash(registerDto.password, 10)
    const user = await this.usersService.create({
      email: registerDto.email,
      password: hashedPassword,
      fullname: `${registerDto.firstName} ${registerDto.lastName}`,
      username: registerDto.email.split('@')[0],
      phone_number: '', // These can be updated later
      address: '', // These can be updated later
      status: 'waiting_deposit', // Default status from migration
      role_id: 'member', // Member role ID (will be created in seeds)
      deposit_image_url: undefined // Optional field
    })

    // Get user with role information for token generation
    const userWithRole = await this.usersService.findByEmailWithRole(user.email)
    return this.generateTokens(userWithRole)
  }

  async refreshToken(user: any) {
    return this.generateTokens(user)
  }

  private generateTokens(user: any) {
    const payload: JwtPayload = {
      sub: user.id,
      email: user.email,
      role: user.role_name || user.role || 'member'
    }

    return {
      access_token: this.jwtService.sign(payload),
      refresh_token: this.jwtService.sign(payload, { expiresIn: '7d' })
    }
  }
}



================================================
FILE: auth/decorators/current-user.decorator.ts
================================================
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
  },
);



================================================
FILE: auth/decorators/roles.decorator.ts
================================================
import { SetMetadata } from '@nestjs/common';
import { UserRole } from '../enums/role.enum';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: UserRole[]) => SetMetadata(ROLES_KEY, roles);



================================================
FILE: auth/dto/login.dto.ts
================================================
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class LoginDto {
  @ApiProperty({ example: 'user@example.com' })
  @IsEmail()
  @IsNotEmpty()
  email = '';

  @ApiProperty({ example: 'password123' })
  @IsString()
  @IsNotEmpty()
  password = '';
}



================================================
FILE: auth/dto/register.dto.ts
================================================
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty, IsString, MinLength } from 'class-validator';

export class RegisterDto {
  @ApiProperty({ example: 'user@example.com' })
  @IsEmail()
  @IsNotEmpty()
  email = '';

  @ApiProperty({ example: 'password123', minLength: 6 })
  @IsString()
  @MinLength(6)
  @IsNotEmpty()
  password = '';

  @ApiProperty({ example: 'John' })
  @IsString()
  @IsNotEmpty()
  firstName = '';

  @ApiProperty({ example: 'Doe' })
  @IsString()
  @IsNotEmpty()
  lastName = '';
}



================================================
FILE: auth/enums/role.enum.ts
================================================
export enum UserRole {
  ADMIN = 'admin',
  MEMBER = 'member',
  STAFF = 'staff',
}



================================================
FILE: auth/guards/auth.guard.ts
================================================
import {
  Injectable,
  ExecutionContext,
  UnauthorizedException
} from '@nestjs/common'
import { AuthGuard } from '@nestjs/passport'
import { JsonWebTokenError, TokenExpiredError } from 'jsonwebtoken'

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  canActivate(context: ExecutionContext) {
    // Add your custom logic here if needed
    return super.canActivate(context)
  }

  handleRequest(err: any, user: any, info: any) {
    // You can throw custom exceptions based on specific errors
    if (info instanceof TokenExpiredError) {
      throw new UnauthorizedException('Token expired')
    }

    if (info instanceof JsonWebTokenError) {
      throw new UnauthorizedException('Invalid token')
    }

    if (err || !user) {
      throw new UnauthorizedException('Unauthorized')
    }

    return user
  }
}



================================================
FILE: auth/guards/roles.guard.ts
================================================
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { ROLES_KEY } from '../decorators/roles.decorator'
import { UserRole } from '../enums/role.enum'

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<UserRole[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ])

    // If no roles are required, allow access
    if (!requiredRoles || requiredRoles.length === 0) {
      return true
    }

    const { user } = context.switchToHttp().getRequest()
    
    // Ensure user exists and has a role
    if (!user || !user.role) {
      throw new ForbiddenException('User has no role assigned')
    }

    // Check if user's role is in the required roles
    const hasRole = requiredRoles.some(role => user.role === role)
    
    if (!hasRole) {
      throw new ForbiddenException(`User with role ${user.role} does not have sufficient permissions`)
    }
    
    return true
  }
}


================================================
FILE: auth/strategies/jwt.strategy.ts
================================================
import { Injectable } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import { PassportStrategy } from '@nestjs/passport'
import { ExtractJwt, Strategy } from 'passport-jwt'
import { JwtPayload } from '../../interface/jwt'

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>(
        'JWT_SECRET',
        'your-default-secret-key'
      )
    })
  }

  async validate(payload: JwtPayload) {
    return {
      id: payload.sub,
      email: payload.email,
      role: payload.role
    }
  }
}



================================================
FILE: database/base.repository.ts
================================================
import { Knex } from 'knex'
import { DatabaseService } from './database.service'

/**
 * Generic base repository class that provides common CRUD operations
 * Uses a generic approach with Knex query builder
 * - T: The entity type (e.g., User)
 */
export abstract class BaseRepository<T> {
  protected readonly knex: Knex

  constructor(
    protected readonly databaseService: DatabaseService,
    protected readonly tableName: string
  ) {
    this.knex = databaseService.getKnex()
  }

  async findAll(): Promise<T[]> {
    const result = await this.knex(this.tableName).select()

    return result as T[]
  }

  /**
   * Find a record by ID
   */
  async findById(id: string): Promise<T | undefined> {
    const result = await this.knex(this.tableName).where('id', id).first()

    return result as T | undefined
  }

  /**
   * Create a new record
   */
  async create(data: Partial<T>): Promise<T> {
    const [result] = await this.knex(this.tableName).insert(data).returning('*')

    return result as T
  }

  /**
   * Update a record by ID
   */
  async updateById(id: string, data: Partial<T>): Promise<T> {
    const [result] = await this.knex(this.tableName)
      .where('id', id)
      .update(data)
      .returning('*')

    return result as T
  }

  /**
   * Delete a record by ID
   */
  async deleteById(id: string): Promise<T> {
    const [result] = await this.knex(this.tableName)
      .where('id', id)
      .del()
      .returning('*')

    return result as T
  }

  /**
   * Get paginated results
   */
  async paginate(
    page = 1,
    perPage = 10
  ): Promise<{ data: T[]; page: number; total: number; totalPage: number }> {
    const offset = (page - 1) * perPage

    // Get paginated data
    const data = await this.knex(this.tableName)
      .select('*')
      .limit(perPage)
      .offset(offset)

    // Get total count
    const [{ count }] = await this.knex(this.tableName).count('* as count')

    const total = parseInt(count as string, 10)
    const totalPage = Math.ceil(total / perPage)

    return {
      data: data as T[],
      page,
      total,
      totalPage
    }
  }
}



================================================
FILE: database/database.config.ts
================================================
import { ConfigService } from '@nestjs/config'
import { Knex } from 'knex'

export const getDatabaseConfig = (
  configService: ConfigService
): Knex.Config => ({
  client: 'pg',
  connection: {
    host: configService.get<string>('DB_HOST'),
    port: configService.get<number>('DB_PORT', 5432),
    user: configService.get<string>('DB_USER'),
    password: configService.get<string>('DB_PASSWORD'),
    database: configService.get<string>('DB_NAME'),
    ssl:
      configService.get<string>('NODE_ENV') === 'production'
        ? { rejectUnauthorized: false }
        : false
  },
  pool: {
    min: parseInt(configService.get<string>('DB_POOL_MIN', '2'), 10),
    max: parseInt(configService.get<string>('DB_POOL_MAX', '10'), 10)
  },
  migrations: {
    directory: './src/database/migrations',
    tableName: 'knex_migrations'
  },
  seeds: {
    directory: './src/database/seeds'
  }
})



================================================
FILE: database/database.module.ts
================================================
import { Module } from '@nestjs/common'
import { ConfigModule } from '@nestjs/config'
import { DatabaseService } from './database.service'

@Module({
  imports: [ConfigModule],
  providers: [DatabaseService],
  exports: [DatabaseService]
})
export class DatabaseModule {}



================================================
FILE: database/database.service.ts
================================================
import {
  Injectable,
  OnModuleDestroy,
  OnModuleInit,
  Logger
} from '@nestjs/common'
import { Knex, knex } from 'knex'
import { ConfigService } from '@nestjs/config'
import { getDatabaseConfig } from './database.config'

@Injectable()
export class DatabaseService implements OnModuleInit, OnModuleDestroy {
  private readonly knex: Knex
  private isDestroyed = false
  private readonly logger = new Logger(DatabaseService.name)

  constructor(private configService: ConfigService) {
    this.knex = knex(getDatabaseConfig(this.configService))
  }

  async onModuleInit() {
    try {
      // Test the connection
      await this.knex.raw('SELECT 1')
      this.logger.log('Database connected successfully')
    } catch (error) {
      this.logger.error('Database connection failed:', error)
      throw error
    }
  }

  getKnex(): Knex {
    if (this.isDestroyed) {
      throw new Error('Database connection has been destroyed')
    }
    return this.knex
  }

  table(tableName: string): Knex.QueryBuilder {
    if (this.isDestroyed) {
      throw new Error('Database connection has been destroyed')
    }
    return this.knex(tableName)
  }

  async onModuleDestroy() {
    if (this.isDestroyed) {
      return
    }

    this.isDestroyed = true

    try {
      await this.knex.destroy()
      this.logger.log('Database connection closed successfully')
    } catch (error) {
      this.logger.error('Error during database cleanup:', error)
    }
  }
}



================================================
FILE: database/migrations/20250531154634_create_roles_table.ts
================================================
import { Knex } from 'knex'

export async function up(knex: Knex): Promise<void> {
  await knex.raw('CREATE EXTENSION IF NOT EXISTS "pgcrypto"')

  await knex.schema.createTable('roles', (table) => {
    table.string('id', 16).primary()
    table.string('name', 64).notNullable().unique()
  })
}

export async function down(knex: Knex): Promise<void> {
  await knex.schema.dropTable('roles')
}



================================================
FILE: database/migrations/20250531160815_create_users_table.ts
================================================
import { Knex } from 'knex'

const userStatus = ['waiting_deposit', 'active', 'suspended', 'pending']

export async function up(knex: Knex): Promise<void> {
  await knex.schema.createTable('users', (table) => {
    table
      .string('id', 36)
      .primary()
      .defaultTo(knex.raw('gen_random_uuid()::varchar'))
    table.string('email').notNullable().unique()
    table.string('fullname').notNullable()
    table.string('username').notNullable().unique()
    table.string('password').notNullable()
    table.string('phone_number').notNullable()
    table.text('address').notNullable()
    table.enum('status', userStatus).notNullable().defaultTo(userStatus[0])
    table
      .string('role_id')
      .references('id')
      .inTable('roles')
      .onDelete('RESTRICT')
      .notNullable()
    table.string('deposit_image_url').nullable()
    table.timestamp('created_at').notNullable().defaultTo(knex.fn.now())
    table.timestamp('updated_at').notNullable().defaultTo(knex.fn.now())
  })
}

export async function down(knex: Knex): Promise<void> {
  await knex.schema.dropTable('users')
}



================================================
FILE: database/migrations/20250531163446_create_notifications_audit_related_table.ts
================================================
import { Knex } from 'knex'

export async function up(knex: Knex): Promise<void> {
  // Create audit_logs table for tracking all administrative actions
  await knex.schema.createTable('audit_logs', (table) => {
    table
      .string('id', 36)
      .primary()
      .defaultTo(knex.raw('gen_random_uuid()::varchar'))
    table
      .string('user_id', 36)
      .references('id')
      .inTable('users')
      .onDelete('SET NULL')
    table.string('action').notNullable()
    table.string('entity_type').notNullable()
    table.string('entity_id').notNullable()
    table.jsonb('old_values')
    table.jsonb('new_values')
    table.string('ip_address')
    table.string('user_agent')
    table.timestamp('created_at').notNullable().defaultTo(knex.fn.now())
  })

  // Create notification_types table
  await knex.schema.createTable('notification_types', (table) => {
    table
      .string('id', 36)
      .primary()
      .defaultTo(knex.raw('gen_random_uuid()::varchar'))
    table.string('name').notNullable().unique()
    table.text('description')
    table.text('template').notNullable()
    table.timestamp('created_at').notNullable().defaultTo(knex.fn.now())
    table.timestamp('updated_at').notNullable().defaultTo(knex.fn.now())
  })

  // Create notifications table
  await knex.schema.createTable('notifications', (table) => {
    table
      .string('id', 36)
      .primary()
      .defaultTo(knex.raw('gen_random_uuid()::varchar'))
    table
      .string('user_id', 36)
      .references('id')
      .inTable('users')
      .onDelete('CASCADE')
      .notNullable()
    table
      .string('notification_type_id', 36)
      .references('id')
      .inTable('notification_types')
      .onDelete('RESTRICT')
      .notNullable()
    table.string('title').notNullable()
    table.text('message').notNullable()
    table.jsonb('data')
    table.boolean('is_read').notNullable().defaultTo(false)
    table.timestamp('read_at')
    table.timestamp('created_at').notNullable().defaultTo(knex.fn.now())
    table.timestamp('updated_at').notNullable().defaultTo(knex.fn.now())
  })

  // Create email_logs table for tracking all sent emails
  await knex.schema.createTable('email_logs', (table) => {
    table
      .string('id', 36)
      .primary()
      .defaultTo(knex.raw('gen_random_uuid()::varchar'))
    table
      .string('user_id', 36)
      .references('id')
      .inTable('users')
      .onDelete('SET NULL')
    table.string('email').notNullable()
    table.string('subject').notNullable()
    table.text('body').notNullable()
    table.string('status').notNullable()
    table.text('error')
    table.timestamp('created_at').notNullable().defaultTo(knex.fn.now())
  })

  // Insert default notification types
  await knex('notification_types').insert([
    {
      name: 'account_approval',
      description: 'Account approval notification',
      template:
        'Your account has been approved. You can now access all features.'
    },
    {
      name: 'transaction_confirmation',
      description: 'Transaction confirmation notification',
      template: 'Your transaction of {{amount}} has been {{status}}.'
    },
    {
      name: 'loan_approval',
      description: 'Loan approval notification',
      template: 'Your loan application for {{amount}} has been {{status}}.'
    },
    {
      name: 'payment_reminder',
      description: 'Payment reminder notification',
      template:
        'Reminder: Your loan payment of {{amount}} is due on {{due_date}}.'
    },
    {
      name: 'late_payment',
      description: 'Late payment notification',
      template:
        'Your loan payment of {{amount}} was due on {{due_date}} and is now overdue.'
    }
  ])

  // Create indexes
  await knex.raw(
    'CREATE INDEX notifications_user_id_idx ON notifications (user_id)'
  )
  await knex.raw(
    'CREATE INDEX notifications_type_id_idx ON notifications (notification_type_id)'
  )
  await knex.raw(
    'CREATE INDEX notifications_unread_idx ON notifications (user_id) WHERE is_read = false'
  )
  await knex.raw('CREATE INDEX audit_logs_user_id_idx ON audit_logs (user_id)')
  await knex.raw('CREATE INDEX email_logs_user_id_idx ON email_logs (user_id)')
}

export async function down(knex: Knex): Promise<void> {
  await knex.raw('DROP INDEX IF EXISTS notifications_unread_idx')
  await knex.raw('DROP INDEX IF EXISTS notifications_user_id_idx')
  await knex.raw('DROP INDEX IF EXISTS notifications_type_id_idx')
  await knex.raw('DROP INDEX IF EXISTS audit_logs_user_id_idx')
  await knex.raw('DROP INDEX IF EXISTS email_logs_user_id_idx')

  await knex.schema.dropTable('email_logs')
  await knex.schema.dropTable('notifications')
  await knex.schema.dropTable('notification_types')
  await knex.schema.dropTable('audit_logs')
}



================================================
FILE: database/seeds/001_roles.ts
================================================
import { Knex } from 'knex'

export async function seed(knex: Knex): Promise<void> {
  await knex('roles').insert([
    {
      id: 'administrator',
      name: 'Administrator'
    },
    {
      id: 'member',
      name: 'Member'
    }
  ])
}



================================================
FILE: database/seeds/002_admin_user.ts
================================================
import { Knex } from 'knex'
import { hash } from 'bcrypt'

export async function seed(knex: Knex): Promise<void> {
  const hashedPassword = await hash('admin123', 10)

  await knex('users').insert([
    {
      id: 'admin-001',
      email: 'admin@lumbungmesari.com',
      fullname: 'System Administrator',
      username: 'admin',
      password: hashedPassword,
      phone_number: '+62812345678',
      address: 'Lumbung Mesari Office',
      status: 'active',
      role_id: 'administrator',
      deposit_image_url: null
    }
  ])
}



================================================
FILE: database/types/audit.ts
================================================
export interface AuditLogTable {
  id: string
  user_id: string | null
  action: string
  entity_type: string
  entity_id: string
  old_values: unknown | null
  new_values: unknown | null
  ip_address: string | null
  user_agent: string | null
  created_at?: Date
}

export interface NotificationTypeTable {
  id: string
  name: string
  description: string | null
  template: string
  created_at?: Date
  updated_at?: Date
}

export interface NotificationTable {
  id: string
  user_id: string
  notification_type_id: string
  title: string
  message: string
  data: unknown | null
  read_at: Date | null
  created_at?: Date
  updated_at?: Date
}

export interface EmailLogTable {
  id: string
  user_id: string | null
  email: string
  subject: string
  template: string
  data: unknown | null
  status: string
  sent_at: Date | null
  error_message: string | null
  created_at?: Date
  updated_at?: Date
}

// Export types
export type AuditLog = AuditLogTable
export type NewAuditLog = Omit<AuditLogTable, 'id' | 'created_at'>
export type UpdateAuditLog = Partial<Omit<AuditLogTable, 'id' | 'created_at'>>

export type NotificationType = NotificationTypeTable
export type NewNotificationType = Omit<
  NotificationTypeTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateNotificationType = Partial<
  Omit<NotificationTypeTable, 'id' | 'created_at' | 'updated_at'>
>

export type Notification = NotificationTable
export type NewNotification = Omit<
  NotificationTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateNotification = Partial<
  Omit<NotificationTable, 'id' | 'created_at' | 'updated_at'>
>

export type EmailLog = EmailLogTable
export type NewEmailLog = Omit<
  EmailLogTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateEmailLog = Partial<
  Omit<EmailLogTable, 'id' | 'created_at' | 'updated_at'>
>



================================================
FILE: database/types/database.ts
================================================
import { UserTable } from './users'
import { RoleTable } from './roles'
import {
  SavingsAccountTable,
  TransactionTable,
  TransactionTypeTable
} from './savings'
import { LoanTable, LoanPeriodTable, InstallmentTable } from './loans'
import {
  AuditLogTable,
  NotificationTable,
  NotificationTypeTable,
  EmailLogTable
} from './audit'

export interface Database {
  // User management
  users: UserTable
  roles: RoleTable
  // Savings management
  savings_accounts: SavingsAccountTable
  transaction_types: TransactionTypeTable
  transactions: TransactionTable
  // Loan management
  loan_periods: LoanPeriodTable
  loans: LoanTable
  installments: InstallmentTable
  // Audit and notifications
  audit_logs: AuditLogTable
  notification_types: NotificationTypeTable
  notifications: NotificationTable
  email_logs: EmailLogTable
}



================================================
FILE: database/types/loans.ts
================================================
export interface LoanPeriodTable {
  id: string
  months: number
  interest_rate: string
  created_at?: Date
  updated_at?: Date
}

export interface LoanTable {
  id: string
  user_id: string
  loan_number: string
  amount: string
  loan_period_id: string
  interest_rate: string
  total_amount: string
  monthly_payment: string
  start_date: Date | null
  end_date: Date | null
  status: string
  approved_by: string | null
  approved_at: Date | null
  created_at?: Date
  updated_at?: Date
}

export interface InstallmentTable {
  id: string
  loan_id: string
  installment_number: number
  amount: string
  due_date: Date
  paid_date: Date | null
  paid_amount: string | null
  late_fee: string | null
  status: string
  created_at?: Date
  updated_at?: Date
}

// Export types
export type LoanPeriod = LoanPeriodTable
export type NewLoanPeriod = Omit<
  LoanPeriodTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateLoanPeriod = Partial<
  Omit<LoanPeriodTable, 'id' | 'created_at' | 'updated_at'>
>

export type Loan = LoanTable
export type NewLoan = Omit<LoanTable, 'id' | 'created_at' | 'updated_at'>
export type UpdateLoan = Partial<
  Omit<LoanTable, 'id' | 'created_at' | 'updated_at'>
>

export type Installment = InstallmentTable
export type NewInstallment = Omit<
  InstallmentTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateInstallment = Partial<
  Omit<InstallmentTable, 'id' | 'created_at' | 'updated_at'>
>



================================================
FILE: database/types/roles.ts
================================================
export interface RoleTable {
  id: string
  name: string
  created_at?: Date
  updated_at?: Date
}

export type Role = RoleTable
export type NewRole = Omit<RoleTable, 'id' | 'created_at' | 'updated_at'>
export type UpdateRole = Partial<
  Omit<RoleTable, 'id' | 'created_at' | 'updated_at'>
>



================================================
FILE: database/types/savings.ts
================================================
export interface SavingsAccountTable {
  id: string
  user_id: string
  account_number: string
  balance: string
  interest_rate: string
  status: string
  created_at?: Date
  updated_at?: Date
}

export interface TransactionTypeTable {
  id: string
  name: string
  description: string | null
  created_at?: Date
  updated_at?: Date
}

export interface TransactionTable {
  id: string
  user_id: string
  savings_account_id: string
  transaction_type_id: string
  amount: string
  balance_before: string
  balance_after: string
  description: string | null
  reference_number: string
  status: string
  processed_at: Date | null
  created_at?: Date
  updated_at?: Date
}

// Export types
export type SavingsAccount = SavingsAccountTable
export type NewSavingsAccount = Omit<
  SavingsAccountTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateSavingsAccount = Partial<
  Omit<SavingsAccountTable, 'id' | 'created_at' | 'updated_at'>
>

export type TransactionType = TransactionTypeTable
export type NewTransactionType = Omit<
  TransactionTypeTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateTransactionType = Partial<
  Omit<TransactionTypeTable, 'id' | 'created_at' | 'updated_at'>
>

export type Transaction = TransactionTable
export type NewTransaction = Omit<
  TransactionTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateTransaction = Partial<
  Omit<TransactionTable, 'id' | 'created_at' | 'updated_at'>
>



================================================
FILE: database/types/users.ts
================================================
export interface UserTable {
  id: string
  email: string
  fullname: string
  username: string
  password: string
  phone_number: string
  address: string
  status: string
  role_id: string
  deposit_image_url?: string
  created_at?: Date
  updated_at?: Date
}

export type User = UserTable
export type NewUser = Omit<UserTable, 'id' | 'created_at' | 'updated_at'>
export type UpdateUser = Partial<
  Omit<UserTable, 'id' | 'created_at' | 'updated_at'>
>



================================================
FILE: interface/jwt.ts
================================================
export interface JwtPayload {
  sub: string
  email: string
  role: string
}



================================================
FILE: interface/users.ts
================================================
export type User = {
  id: string
  email: string
  fullname: string
  username: string
  password: string
  phone_number: string
  address: string
  status: string
  role_id: string
  deposit_image_url: string
  created_at: Date
  updated_at: Date
}



================================================
FILE: users/users.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing'
import { UsersController } from './users.controller'
import { UsersService } from './users.service'

describe('UsersController', () => {
  let controller: UsersController

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [UsersController],
      providers: [UsersService]
    }).compile()

    controller = module.get<UsersController>(UsersController)
  })

  it('should be defined', () => {
    expect(controller).toBeDefined()
  })

  it('should return all users', async () => {
    const result = await controller.findAllV1()
    expect(result).toBe('Hello World')
  })
})



================================================
FILE: users/users.controller.ts
================================================
import { Controller, Get, Version, VERSION_NEUTRAL } from '@nestjs/common'
import { UsersService } from './users.service'

@Controller('/users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Version(VERSION_NEUTRAL)
  @Get()
  async findAllNeutral() {
    return this.findAllV1()
  }

  @Version('1')
  @Get()
  async findAllV1() {
    return this.usersService.findAll()
  }

  @Version('2')
  @Get()
  async findAllV2() {
    return this.usersService.findAll()
  }
}



================================================
FILE: users/users.module.ts
================================================
import { Module } from '@nestjs/common'
import { UsersController } from './users.controller'
import { UsersService } from './users.service'
import { UsersRepository } from './users.repository'
import { DatabaseModule } from '../database/database.module'

@Module({
  imports: [DatabaseModule],
  controllers: [UsersController],
  providers: [UsersService, UsersRepository],
  exports: [UsersService]
})
export class UsersModule {}



================================================
FILE: users/users.repository.ts
================================================
import { Injectable } from '@nestjs/common'
import { BaseRepository } from '../database/base.repository'
import { DatabaseService } from '../database/database.service'
import { User, NewUser, UpdateUser } from '../database/types/users'

@Injectable()
export class UsersRepository extends BaseRepository<User> {
  constructor(protected readonly databaseService: DatabaseService) {
    super(databaseService, 'users')
  }

  async findByEmail(email: string): Promise<User | undefined> {
    const result = await this.knex('users').where('email', email).first()

    return result as User | undefined
  }

  async findByEmailWithRole(
    email: string
  ): Promise<(User & { role_name: string }) | undefined> {
    const result = await this.knex('users')
      .join('roles', 'roles.id', 'users.role_id')
      .select([
        'users.id',
        'users.email',
        'users.fullname',
        'users.username',
        'users.password',
        'users.phone_number',
        'users.address',
        'users.status',
        'users.role_id',
        'users.deposit_image_url',
        'users.created_at',
        'users.updated_at',
        'roles.name as role_name'
      ])
      .where('users.email', email)
      .first()

    return result as (User & { role_name: string }) | undefined
  }

  async findByUsername(username: string): Promise<User | undefined> {
    const result = await this.knex('users').where('username', username).first()

    return result as User | undefined
  }

  async findAllWithRoles(
    page = 1,
    limit = 10
  ): Promise<{
    data: (User & { role_name: string })[]
    total: number
    page: number
    limit: number
  }> {
    const offset = (page - 1) * limit

    // Get total count
    const [{ count }] = await this.knex('users').count('id as count')

    // Get users with role information
    const data = await this.knex('users')
      .join('roles', 'roles.id', 'users.role_id')
      .select([
        'users.id',
        'users.email',
        'users.fullname',
        'users.username',
        'users.phone_number',
        'users.address',
        'users.status',
        'users.role_id',
        'users.deposit_image_url',
        'users.created_at',
        'users.updated_at',
        'roles.name as role_name'
      ])
      .limit(limit)
      .offset(offset)

    return {
      data: data as (User & { role_name: string })[],
      total: Number(count),
      page,
      limit
    }
  }

  async createUser(data: NewUser): Promise<User> {
    return this.create(data as User)
  }

  async updateUser(id: string, data: UpdateUser): Promise<User> {
    return this.updateById(id, data as User)
  }

  async updateStatus(id: string, status: string): Promise<User> {
    return this.updateById(id, { status } as any)
  }
}



================================================
FILE: users/users.service.ts
================================================
import { Injectable, ConflictException } from '@nestjs/common'
import { NewUser } from '../database/types/users'
import { UsersRepository } from './users.repository'

@Injectable()
export class UsersService {
  constructor(private usersRepository: UsersRepository) {}

  async findByEmail(email: string) {
    return await this.usersRepository.findByEmail(email)
  }

  async findByEmailWithRole(email: string) {
    return await this.usersRepository.findByEmailWithRole(email)
  }

  async create(userData: NewUser) {
    const existingUser = await this.findByEmail(userData.email)
    if (existingUser) {
      throw new ConflictException('Email already exists')
    }

    return await this.usersRepository.create(userData)
  }

  async findAll() {
    return await this.usersRepository.findAll()
  }
}
