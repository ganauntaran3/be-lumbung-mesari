Directory structure:
└── be-lumbung-mesari/
    ├── README.md
    ├── docker-compose-dev.yml
    ├── knexfile.ts
    ├── nest-cli.json
    ├── package.json
    ├── Pedoman_Wawancara_Stakeholder_Koperasi.md
    ├── tsconfig.build.json
    ├── tsconfig.json
    ├── .env.example
    ├── .eslintrc.js
    ├── .prettierrc
    └── src/
        ├── app.controller.spec.ts
        ├── app.controller.ts
        ├── app.module.ts
        ├── app.service.ts
        ├── main.ts
        ├── auth/
        │   ├── auth.controller.ts
        │   ├── auth.module.ts
        │   ├── auth.service.ts
        │   ├── decorators/
        │   │   ├── current-user.decorator.ts
        │   │   └── roles.decorator.ts
        │   ├── dto/
        │   │   ├── login.dto.ts
        │   │   └── register.dto.ts
        │   ├── enums/
        │   │   └── role.enum.ts
        │   ├── guards/
        │   │   ├── auth.guard.ts
        │   │   └── roles.guard.ts
        │   └── strategies/
        │       └── jwt.strategy.ts
        ├── database/
        │   ├── base.repository.ts
        │   ├── database.config.ts
        │   ├── database.module.ts
        │   ├── database.service.ts
        │   ├── migrations/
        │   │   ├── 20250531154634_create_roles_table.ts
        │   │   ├── 20250531160815_create_users_table.ts
        │   │   └── 20250531163446_create_notifications_audit_related_table.ts
        │   ├── seeds/
        │   │   ├── 001_roles.ts
        │   │   └── 002_admin_user.ts
        │   └── types/
        │       ├── audit.ts
        │       ├── database.ts
        │       ├── loans.ts
        │       ├── roles.ts
        │       ├── savings.ts
        │       └── users.ts
        ├── interface/
        │   ├── jwt.ts
        │   └── users.ts
        └── users/
            ├── users.controller.spec.ts
            ├── users.controller.ts
            ├── users.module.ts
            ├── users.repository.ts
            └── users.service.ts

================================================
FILE: README.md
================================================
# Backend API for Seka Lumbung Mesari

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
# install node
$ node -v
# Version used: >22.x

# If you don't have node, install it from https://nodejs.org/en/download/
# If you don't have npm, install it from https://www.npmjs.com/get-npm

# Install node version 22.x
$ nvm install 22.x
$ nvm use 22.x


# install dependencies
$ npm install
```

## Run the project

### Docker

```bash
# Run project dependencies with docker (postgresql)
$ docker-compose -f docker-compose-dev.yml up -d

# Connect with the database
psql -h localhost -p 5432 -U admin -d db_lumbung_mesari
```

### Local

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).



================================================
FILE: docker-compose-dev.yml
================================================
version: '3.8'
services:
  postgres:
    image: postgres:17
    container_name: postgres
    environment:
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: admin123
      POSTGRES_DB: db_lumbung_mesari
    ports:
      - '5432:5432'
    volumes:
      - postgres_data:/var/lib/postgresql/data
  adminer:
    image: adminer
    container_name: adminer
    ports:
      - '8080:8080'
    environment:
      ADMINER_DEFAULT_SERVER: postgres
      ADMINER_DEFAULT_USER: admin
      ADMINER_DEFAULT_PASSWORD: admin123
      ADMINER_DEFAULT_DB: db_lumbung_mesari
    depends_on:
      - postgres
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U admin']
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
    driver: local



================================================
FILE: knexfile.ts
================================================
import { configDotenv } from 'dotenv'

configDotenv()

const config = {
  development: {
    client: 'pg',
    connection: {
      database: process.env.DB_NAME,
      host: process.env.DB_HOST,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      port: process.env.DB_PORT || 5432
    },
    pool: {
      min: parseInt(process.env.DB_POOL_MIN || '2'),
      max: parseInt(process.env.DB_POOL_MAX || '10')
    },
    migrations: {
      directory: './src/database/migrations',
      tableName: 'knex_migrations'
    },
    seeds: {
      directory: './src/database/seeds'
    }
  },
  staging: {
    client: 'pg',
    connection: {
      database: process.env.DB_NAME,
      host: process.env.DB_HOST,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      port: process.env.DB_PORT || 5432,
      ssl: { rejectUnauthorized: false }
    },
    pool: {
      min: parseInt(process.env.DB_POOL_MIN || '2'),
      max: parseInt(process.env.DB_POOL_MAX || '10')
    },
    migrations: {
      directory: './src/database/migrations',
      tableName: 'knex_migrations'
    },
    seeds: {
      directory: './src/database/seeds'
    }
  },
  production: {
    client: 'pg',
    connection: {
      database: process.env.DB_NAME,
      host: process.env.DB_HOST,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      port: process.env.DB_PORT || 5432,
      ssl: { rejectUnauthorized: false }
    },
    pool: {
      min: parseInt(process.env.DB_POOL_MIN || '2'),
      max: parseInt(process.env.DB_POOL_MAX || '10')
    },
    migrations: {
      directory: './src/database/migrations',
      tableName: 'knex_migrations'
    },
    seeds: {
      directory: './src/database/seeds'
    }
  }
}

export default config



================================================
FILE: nest-cli.json
================================================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}



================================================
FILE: package.json
================================================
{
  "name": "api-lumbung-mesari",
  "private": true,
  "version": "0.0.1",
  "description": "Backend Application for Lumbung Mesari",
  "license": "MIT",
  "engines": {
    "node": "22.x"
  },
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/jest/bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "make:migration": "knex migrate:make",
    "migrate:latest": "knex migrate:latest",
    "migrate:up": "knex migrate:up",
    "migrate:down": "knex migrate:down",
    "migrate:rollback": "knex migrate:rollback",
    "migrate:status": "knex migrate:status",
    "seed:run": "knex seed:run",
    "seed:make": "knex seed:make"
  },
  "dependencies": {
    "@nestjs/common": "^10.4.15",
    "@nestjs/config": "^4.0.0",
    "@nestjs/core": "^10.4.15",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^10.4.15",
    "@nestjs/schedule": "^5.0.1",
    "@nestjs/swagger": "^8.1.1",
    "@nestjs/throttler": "^6.4.0",
    "bcrypt": "^5.1.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "compression": "^1.8.0",
    "decimal.js": "^10.6.0",
    "helmet": "^8.0.0",
    "knex": "^3.1.0",
    "module": "^1.2.5",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "pg": "^8.16.3",
    "reflect-metadata": "^0.2.0",
    "rxjs": "^7.8.1"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.4.15",
    "@types/bcrypt": "^5.0.2",
    "@types/compression": "^1.7.5",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.2",
    "@types/node": "^20.17.57",
    "@types/passport-jwt": "^4.0.1",
    "@types/pg": "^8.15.5",
    "@types/supertest": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^8.0.0",
    "@typescript-eslint/parser": "^8.0.0",
    "eslint": "^9.20.1",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.7.0",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: Pedoman_Wawancara_Stakeholder_Koperasi.md
================================================
# Pedoman Wawancara Penggalian Kebutuhan Sistem Informasi Koperasi Simpan Pinjam

Pedoman ini digunakan untuk melakukan wawancara terstruktur dengan stakeholder koperasi guna menggali permasalahan nyata yang akan menjadi dasar revisi proposal tugas akhir.

---

## 🧑‍💼 1. Ketua / Pengelola Koperasi

### Tujuan:

- Mengetahui visi-misi koperasi
- Memahami tantangan strategis
- Mengetahui laporan-laporan wajib koperasi

### Pertanyaan:

1. Layanan apa saja yang disediakan oleh koperasi? (simpan, pinjam, etc)
2. Apakah layanan tersebut terbagi lagi ke dalam beberapa jenis? (misal: simpanan → pokok, wajib, sukarela)
3. Dari layanan yang ada, mana yang paling sering digunakan oleh anggota?
4. Bagaimana proses seseorang bisa menjadi anggota koperasi ini? (Output: sequence)
5. Bagaimana proses simpanan dilakukan oleh anggota? (Output: sequence)
6. Bagaimana proses pengajuan pinjaman dilakukan oleh anggota? (Output: sequence)
7. Bagaimana perhitungan angsuran pinjaman dilakukan oleh koperasi?
8. Apakah ada batasan jumlah pinjaman yang dapat diambil oleh anggota?
9. Apa saja jenis laporan rutin yang diwajibkan untuk dibuat oleh koperasi?
10. Kepada siapa saja laporan-laporan tersebut dikirimkan?
11. Seperti apa rencana koperasi men-digitalisasi proses operasionalnya?

---

## 💰 2. Bendahara Koperasi

### Tujuan:

- Memahami detail alur pencatatan transaksi
- Mengetahui struktur dan siklus laporan keuangan
- Mengidentifikasi kendala teknis pelaporan

### Pertanyaan:

1. Apa saja dokumen yang perlu dikelola atau kewajiban lain yang perlu dilakukan bendahara?
2. Apakah ada laporan yang perlu disusun secara rutin (harian, bulanan, tahunan)?
3. Bagaimana data - data tersebut disimpan?
4. Apakah data - data tersebut perlu di-distribusikan kepada pengurus lain?
5. Jika ada, berapa lama waktu yang dibutuhkan untuk menyusun laporan tersebut?
6. Apa media yang digunakan? (kertas, Excel, aplikasi?)
7. Tantangan apa yang paling sering dirasakan dalam menjalankan pekerjaan?

---

## 🗂️ 3. Sekretaris Koperasi

### Tujuan:

- Memahami proses administrasi dan dokumentasi anggota
- Mengetahui alur pendaftaran dan pengelolaan data keanggotaan
- Mengidentifikasi kebutuhan pengarsipan dan akses data

### Pertanyaan:

1. Apa saja dokumen atau proses yang perlu dikelola oleh sekretaris?
2. Apakah ada data yang perlu diperbarui secara rutin? Jika iya, sebutkan masing - masing prosesnya.
3. Apakah data - data tersebut perlu di-distribusikan kepada pengurus lain?
4. Apakah Anda pernah kesulitan mencari data historikal tertentu?
5. Tantangan apa yang paling sering dirasakan dalam menjalankan pekerjaan?

---

## 🧾 4 . Admin / Petugas Operasional

### Tujuan:

- Mengetahui alur input data harian
- Memahami kendala penggunaan sistem manual

### Pertanyaan:

1. Apa saja pekerjaan harian yang biasa Anda lakukan di koperasi?
2. Transaksi apa saja yang Anda catat? (misalnya: simpanan, angsuran, pengambilan dana)
3. Media apa yang digunakan untuk mencatat transaksi? (buku, Excel, form fisik, dll)
4. Apakah Anda pernah mengalami kesulitan saat mencatat transaksi atau proses lainnya? Jika ya, dalam hal apa?
5. Apakah ada laporan atau data yang perlu disusun secara rutin (harian, bulanan, tahunan)?
6. Apakah ada laporan atau data yang harus disiapkan untuk Rapat Anggota Tahunan (RAT)?
7. Apa kendala yang sering Anda temui dalam pekerjaan Anda sehari-hari?
8. Jika tersedia sistem digital, bagian mana dari pekerjaan Anda yang paling ingin Anda otomatisasi?

---

## 👥 4. Anggota Koperasi

### Tujuan:

- Memahami pengalaman anggota terhadap layanan
- Menilai kebutuhan transparansi dan akses data

### Pertanyaan:

1. Bagaimana proses Anda saat ingin menyetor simpanan atau mengajukan pinjaman?
2. Apakah Anda selalu menerima bukti transaksi atau catatan keuangan dari koperasi?
3. Apakah Anda bisa mengakses informasi tentang status pinjaman, saldo simpanan atau informasi lain Anda dengan mudah?
4. Apakah Anda pernah mengalami kesulitan atau keterlambatan informasi dari pihak koperasi?
5. Jika disediakan sistem online atau aplikasi, apakah Anda tertarik menggunakannya untuk mengecek data pribadi Anda? Apa ekspektasi anda terhadap fitur-fitur yang perlu disediakan?
6. Menurut Anda, apa hal yang perlu ditingkatkan dari layanan koperasi saat ini?

---

## 📌 Catatan Wawancara

Selalu minta izin untuk mencatat atau merekam percakapan. Simpan hasil wawancara sebagai data pendukung untuk memperkuat proposal.



================================================
FILE: tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "strict": true,
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  }
}



================================================
FILE: .env.example
================================================
#Global
PORT=8000   

#Environment
NODE_ENV=
APPLICATION_NAME=

# Database
DB_HOST=
DB_PORT=
DB_NAME=
DB_USER=
DB_PASSWORD=
DB_POOL_MIN=
DB_POOL_MAX=

#JWT
JWT_SECRET=""
JWT_EXPIRES_IN=1h



================================================
FILE: .eslintrc.js
================================================
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
  },
};



================================================
FILE: .prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "none",
  "semi": false
}



================================================
FILE: src/app.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let app: TestingModule;

  beforeAll(async () => {
    app = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();
  });

  describe('getHello', () => {
    it('should return "Hello World!"', () => {
      const appController = app.get(AppController);
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});



================================================
FILE: src/app.controller.ts
================================================
import { Controller } from '@nestjs/common'
import { AppService } from './app.service'

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}
}



================================================
FILE: src/app.module.ts
================================================
import { Module } from '@nestjs/common'
import { AppController } from './app.controller'
import { AppService } from './app.service'
import { UsersModule } from './users/users.module'
import { ConfigModule } from '@nestjs/config'
import { AuthModule } from './auth/auth.module'

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env'
    }),
    UsersModule,
    AuthModule
  ],
  controllers: [AppController],
  providers: [AppService]
})
export class AppModule {}



================================================
FILE: src/app.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}



================================================
FILE: src/main.ts
================================================
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger'
import helmet from 'helmet'
import * as compression from 'compression'
import { ConfigService } from '@nestjs/config'
import { ValidationPipe } from '@nestjs/common'

async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  const configService = app.get(ConfigService)

  // Class Validator Pipeline
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true
    })
  )

  // Security Middleware
  app.use(helmet())
  app.use(compression())
  app.enableCors()

  app.setGlobalPrefix('api')

  // Swagger Configuration (Non-Versioned)
  const config = new DocumentBuilder()
    .setTitle('Lumbung Mesari API')
    .setDescription('The Lumbung Mesari API documentation')
    .setVersion('1.0')
    .addBearerAuth()
    .build()

  const document = SwaggerModule.createDocument(app, config)
  SwaggerModule.setup('docs', app, document, {
    swaggerOptions: {
      persistAuthorization: true,
      displayRequestDuration: true,
      docExpansion: 'none',
      filter: true,
      showRequestHeaders: true
    }
  })

  const port = configService.get<number>('PORT', 8000)
  await app.listen(port)
}

bootstrap()



================================================
FILE: src/auth/auth.controller.ts
================================================
import { Body, Controller, Post, UseGuards, Request, Get } from '@nestjs/common'
import { ApiOperation, ApiResponse, ApiBody } from '@nestjs/swagger'
import { AuthService } from './auth.service'
import { LoginRequestDto, LoginResponseDto } from './dto/login.dto'
import { RegisterDto } from './dto/register.dto'
import { JwtAuthGuard } from './guards/auth.guard'
import { Roles } from './decorators/roles.decorator'
import { RolesGuard } from './guards/roles.guard'
import { UserRole } from './enums/role.enum'
import { CurrentUser } from './decorators/current-user.decorator'

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('login')
  @ApiOperation({ summary: 'User login with email or username' })
  @ApiResponse({
    status: 201,
    description: 'Successfully logged in',
    type: LoginResponseDto
  })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiBody({
    type: LoginRequestDto,
    examples: {
      'Login with email': {
        value: {
          identifier: 'admin@lumbungmesari.com',
          password: 'admin123'
        }
      },
      'Login with username': {
        value: {
          identifier: 'admin',
          password: 'admin123'
        }
      }
    }
  })
  async login(@Body() loginDto: LoginRequestDto) {
    return this.authService.login(loginDto)
  }

  @Post('register')
  @ApiOperation({ summary: 'Register a new user' })
  @ApiResponse({
    status: 201,
    description: 'User registered successfully',
    type: LoginResponseDto
  })
  @ApiResponse({ status: 400, description: 'Bad request' })
  async register(@Body() registerDto: RegisterDto) {
    return this.authService.register(registerDto)
  }

  @UseGuards(JwtAuthGuard)
  @Post('refresh')
  @ApiOperation({ summary: 'Refresh access token' })
  @ApiResponse({
    status: 201,
    description: 'Token refreshed',
    type: LoginResponseDto
  })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  async refresh(@Request() req: { user: any }) {
    return this.authService.refreshToken(req.user)
  }

  @UseGuards(JwtAuthGuard)
  @Get('profile')
  @ApiOperation({ summary: 'Get user profile' })
  @ApiResponse({ status: 200, description: 'Profile retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  getProfile(@CurrentUser() user: any) {
    return user
  }

  @UseGuards(RolesGuard, JwtAuthGuard)
  @Roles(UserRole.ADMIN)
  @Get('admin')
  @ApiOperation({ summary: 'Admin only endpoint' })
  @ApiResponse({
    status: 200,
    description: 'Admin data retrieved successfully'
  })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({
    status: 403,
    description: 'Forbidden - Insufficient permissions'
  })
  getAdminData(@CurrentUser() user: any) {
    return {
      message: 'This is admin only data',
      user
    }
  }
}



================================================
FILE: src/auth/auth.module.ts
================================================
import { Module } from '@nestjs/common'
import { JwtModule } from '@nestjs/jwt'
import { PassportModule } from '@nestjs/passport'
import { ConfigModule, ConfigService } from '@nestjs/config'
import { UsersModule } from '../users/users.module'
import { AuthService } from './auth.service'
import { AuthController } from './auth.controller'
import { JwtStrategy } from './strategies/jwt.strategy'

@Module({
  imports: [
    UsersModule,
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>(
          'JWT_SECRET',
          'your-default-secret-key'
        ),
        signOptions: {
          expiresIn: configService.get<string>('JWT_EXPIRES_IN', '1h')
        }
      }),
      inject: [ConfigService]
    })
  ],
  providers: [AuthService, JwtStrategy],
  controllers: [AuthController],
  exports: [AuthService]
})
export class AuthModule {}



================================================
FILE: src/auth/auth.service.ts
================================================
import { Injectable, UnauthorizedException } from '@nestjs/common'
import { JwtService } from '@nestjs/jwt'
import { compare, hash } from 'bcrypt'
import { UsersService } from '../users/users.service'
import { LoginRequestDto } from './dto/login.dto'
import { RegisterDto } from './dto/register.dto'
import { JwtPayload } from '../interface/jwt'

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService
  ) {}

  async validateUser(identifier: string, password: string): Promise<any> {
    const user = await this.usersService.findByIdentifierWithRole(identifier)
    if (user && (await compare(password, user.password))) {
      const { password, ...result } = user
      return result
    }
    return null
  }

  async login(loginDto: LoginRequestDto) {
    const user = await this.validateUser(loginDto.identifier, loginDto.password)
    if (!user) {
      throw new UnauthorizedException('Invalid credentials')
    }
    return this.generateTokens(user)
  }

  async register(registerDto: RegisterDto) {
    const hashedPassword = await hash(registerDto.password, 10)
    const user = await this.usersService.create({
      email: registerDto.email,
      password: hashedPassword,
      fullname: `${registerDto.firstName} ${registerDto.lastName}`,
      username: registerDto.email.split('@')[0],
      phone_number: '', // These can be updated later
      address: '', // These can be updated later
      status: 'waiting_deposit', // Default status from migration
      role_id: 'member', // Member role ID (will be created in seeds)
      deposit_image_url: undefined // Optional field
    })

    // Get user with role information for token generation
    const userWithRole = await this.usersService.findByEmailWithRole(user.email)
    return this.generateTokens(userWithRole)
  }

  async refreshToken(user: any) {
    return this.generateTokens(user)
  }

  private generateTokens(user: any) {
    const payload: JwtPayload = {
      sub: user.id,
      email: user.email,
      role: user.role || 'member'
    }

    return {
      access_token: this.jwtService.sign(payload),
      refresh_token: this.jwtService.sign(payload, { expiresIn: '1d' })
    }
  }
}



================================================
FILE: src/auth/decorators/current-user.decorator.ts
================================================
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
  },
);



================================================
FILE: src/auth/decorators/roles.decorator.ts
================================================
import { SetMetadata } from '@nestjs/common';
import { UserRole } from '../enums/role.enum';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: UserRole[]) => SetMetadata(ROLES_KEY, roles);



================================================
FILE: src/auth/dto/login.dto.ts
================================================
import { ApiProperty } from '@nestjs/swagger'
import { IsString, IsNotEmpty } from 'class-validator'

export class LoginRequestDto {
  @ApiProperty({
    description: 'Email or Username',
    example: 'admin@lumbungmesari.com',
    required: true
  })
  @IsString()
  @IsNotEmpty()
  identifier = ''

  @ApiProperty({
    description: 'Password',
    example: 'admin123',
    required: true
  })
  @IsString()
  @IsNotEmpty()
  password = ''
}

export class LoginResponseDto {
  @ApiProperty({
    description: 'JWT access token for authentication',
    example:
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhZG1pbi0wMDEiLCJlbWFpbCI6ImFkbWluQGx1bWJ1bmdtZXNhcmkuY29tIiwicm9sZSI6ImFkbWluaXN0cmF0b3IiLCJpYXQiOjE3MDQwNjcyMDAsImV4cCI6MTcwNDA3MDgwMH0.example'
  })
  access_token = ''

  @ApiProperty({
    description: 'JWT refresh token for token renewal',
    example:
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhZG1pbi0wMDEiLCJlbWFpbCI6ImFkbWluQGx1bWJ1bmdtZXNhcmkuY29tIiwicm9sZSI6ImFkbWluaXN0cmF0b3IiLCJpYXQiOjE3MDQwNjcyMDAsImV4cCI6MTcwNDY3MjAwMH0.example'
  })
  refresh_token = ''
}



================================================
FILE: src/auth/dto/register.dto.ts
================================================
import { ApiProperty } from '@nestjs/swagger'
import { IsEmail, IsNotEmpty, IsString, MinLength } from 'class-validator'

export class RegisterDto {
  @ApiProperty({
    example: 'user@example.com',
    description: 'User email address',
    type: String,
    required: true
  })
  @IsEmail()
  @IsNotEmpty()
  email!: string

  @ApiProperty({
    example: 'password123',
    description: 'User password (minimum 6 characters)',
    type: String,
    minLength: 6,
    required: true
  })
  @IsString()
  @MinLength(6)
  @IsNotEmpty()
  password!: string

  @ApiProperty({
    example: 'John',
    description: 'User first name',
    type: String,
    required: true
  })
  @IsString()
  @IsNotEmpty()
  firstName!: string

  @ApiProperty({
    example: 'Doe',
    description: 'User last name',
    type: String,
    required: true
  })
  @IsString()
  @IsNotEmpty()
  lastName!: string
}



================================================
FILE: src/auth/enums/role.enum.ts
================================================
export enum UserRole {
  SUPERADMIN = 'superadministrator',
  ADMIN = 'admin',
  MEMBER = 'member'
}



================================================
FILE: src/auth/guards/auth.guard.ts
================================================
import {
  Injectable,
  ExecutionContext,
  UnauthorizedException
} from '@nestjs/common'
import { AuthGuard } from '@nestjs/passport'
import { JsonWebTokenError, TokenExpiredError } from 'jsonwebtoken'

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  canActivate(context: ExecutionContext) {
    // Add your custom logic here if needed
    return super.canActivate(context)
  }

  handleRequest(err: any, user: any, info: any) {
    // You can throw custom exceptions based on specific errors
    if (info instanceof TokenExpiredError) {
      throw new UnauthorizedException('Token expired')
    }

    if (info instanceof JsonWebTokenError) {
      throw new UnauthorizedException('Invalid token')
    }

    if (err || !user) {
      throw new UnauthorizedException('Unauthorized')
    }

    return user
  }
}



================================================
FILE: src/auth/guards/roles.guard.ts
================================================
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { ROLES_KEY } from '../decorators/roles.decorator'
import { UserRole } from '../enums/role.enum'

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<UserRole[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ])

    // If no roles are required, allow access
    if (!requiredRoles || requiredRoles.length === 0) {
      return true
    }

    const { user } = context.switchToHttp().getRequest()
    
    // Ensure user exists and has a role
    if (!user || !user.role) {
      throw new ForbiddenException('User has no role assigned')
    }

    // Check if user's role is in the required roles
    const hasRole = requiredRoles.some(role => user.role === role)
    
    if (!hasRole) {
      throw new ForbiddenException(`User with role ${user.role} does not have sufficient permissions`)
    }
    
    return true
  }
}


================================================
FILE: src/auth/strategies/jwt.strategy.ts
================================================
import { Injectable } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import { PassportStrategy } from '@nestjs/passport'
import { ExtractJwt, Strategy } from 'passport-jwt'
import { JwtPayload } from '../../interface/jwt'

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>(
        'JWT_SECRET',
        'your-default-secret-key'
      )
    })
  }

  async validate(payload: JwtPayload) {
    return {
      id: payload.sub,
      email: payload.email,
      role: payload.role
    }
  }
}



================================================
FILE: src/database/base.repository.ts
================================================
import { Knex } from 'knex'
import { DatabaseService } from './database.service'

/**
 * Generic base repository class that provides common CRUD operations
 * Uses a generic approach with Knex query builder
 * - T: The entity type (e.g., User)
 */
export abstract class BaseRepository<T> {
  protected readonly knex: Knex

  constructor(
    protected readonly databaseService: DatabaseService,
    protected readonly tableName: string
  ) {
    this.knex = databaseService.getKnex()
  }

  async findAll(): Promise<T[]> {
    const result = await this.knex(this.tableName).select()

    return result as T[]
  }

  /**
   * Find a record by ID
   */
  async findById(id: string): Promise<T | undefined> {
    const result = await this.knex(this.tableName).where('id', id).first()

    return result as T | undefined
  }

  /**
   * Create a new record
   */
  async create(data: Partial<T>): Promise<T> {
    const [result] = await this.knex(this.tableName).insert(data).returning('*')

    return result as T
  }

  /**
   * Update a record by ID
   */
  async updateById(id: string, data: Partial<T>): Promise<T> {
    const [result] = await this.knex(this.tableName)
      .where('id', id)
      .update(data)
      .returning('*')

    return result as T
  }

  /**
   * Delete a record by ID
   */
  async deleteById(id: string): Promise<T> {
    const [result] = await this.knex(this.tableName)
      .where('id', id)
      .del()
      .returning('*')

    return result as T
  }

  /**
   * Get paginated results
   */
  async paginate(
    page = 1,
    perPage = 10
  ): Promise<{ data: T[]; page: number; total: number; totalPage: number }> {
    const offset = (page - 1) * perPage

    // Get paginated data
    const data = await this.knex(this.tableName)
      .select('*')
      .limit(perPage)
      .offset(offset)

    // Get total count
    const [{ count }] = await this.knex(this.tableName).count('* as count')

    const total = parseInt(count as string, 10)
    const totalPage = Math.ceil(total / perPage)

    return {
      data: data as T[],
      page,
      total,
      totalPage
    }
  }
}



================================================
FILE: src/database/database.config.ts
================================================
import { ConfigService } from '@nestjs/config'
import { Knex } from 'knex'

export const getDatabaseConfig = (
  configService: ConfigService
): Knex.Config => ({
  client: 'pg',
  connection: {
    host: configService.get<string>('DB_HOST'),
    port: configService.get<number>('DB_PORT', 5432),
    user: configService.get<string>('DB_USER'),
    password: configService.get<string>('DB_PASSWORD'),
    database: configService.get<string>('DB_NAME'),
    ssl:
      configService.get<string>('NODE_ENV') === 'production'
        ? { rejectUnauthorized: false }
        : false
  },
  pool: {
    min: parseInt(configService.get<string>('DB_POOL_MIN', '2'), 10),
    max: parseInt(configService.get<string>('DB_POOL_MAX', '10'), 10)
  },
  migrations: {
    directory: './src/database/migrations',
    tableName: 'knex_migrations'
  },
  seeds: {
    directory: './src/database/seeds'
  }
})



================================================
FILE: src/database/database.module.ts
================================================
import { Module } from '@nestjs/common'
import { ConfigModule } from '@nestjs/config'
import { DatabaseService } from './database.service'

@Module({
  imports: [ConfigModule],
  providers: [DatabaseService],
  exports: [DatabaseService]
})
export class DatabaseModule {}



================================================
FILE: src/database/database.service.ts
================================================
import {
  Injectable,
  OnModuleDestroy,
  OnModuleInit,
  Logger
} from '@nestjs/common'
import { Knex, knex } from 'knex'
import { ConfigService } from '@nestjs/config'
import { getDatabaseConfig } from './database.config'

@Injectable()
export class DatabaseService implements OnModuleInit, OnModuleDestroy {
  private readonly knex: Knex
  private isDestroyed = false
  private readonly logger = new Logger(DatabaseService.name)

  constructor(private configService: ConfigService) {
    this.knex = knex(getDatabaseConfig(this.configService))
  }

  async onModuleInit() {
    try {
      // Test the connection
      await this.knex.raw('SELECT 1')
      this.logger.log('Database connected successfully')
    } catch (error) {
      this.logger.error('Database connection failed:', error)
      throw error
    }
  }

  getKnex(): Knex {
    if (this.isDestroyed) {
      throw new Error('Database connection has been destroyed')
    }
    return this.knex
  }

  table(tableName: string): Knex.QueryBuilder {
    if (this.isDestroyed) {
      throw new Error('Database connection has been destroyed')
    }
    return this.knex(tableName)
  }

  async onModuleDestroy() {
    if (this.isDestroyed) {
      return
    }

    this.isDestroyed = true

    try {
      await this.knex.destroy()
      this.logger.log('Database connection closed successfully')
    } catch (error) {
      this.logger.error('Error during database cleanup:', error)
    }
  }
}



================================================
FILE: src/database/migrations/20250531154634_create_roles_table.ts
================================================
import { Knex } from 'knex'

export async function up(knex: Knex): Promise<void> {
  await knex.raw('CREATE EXTENSION IF NOT EXISTS "pgcrypto"')

  await knex.schema.createTable('roles', (table) => {
    table.string('id', 16).primary()
    table.string('name', 64).notNullable().unique()
  })
}

export async function down(knex: Knex): Promise<void> {
  await knex.schema.dropTable('roles')
}



================================================
FILE: src/database/migrations/20250531160815_create_users_table.ts
================================================
import { Knex } from 'knex'

const userStatus = ['waiting_deposit', 'active', 'suspended', 'pending']

export async function up(knex: Knex): Promise<void> {
  await knex.schema.createTable('users', (table) => {
    table
      .string('id', 36)
      .primary()
      .defaultTo(knex.raw('gen_random_uuid()::varchar'))
    table.string('email').notNullable().unique()
    table.string('fullname').notNullable()
    table.string('username').notNullable().unique()
    table.string('password').notNullable()
    table.string('phone_number').notNullable()
    table.text('address').notNullable()
    table.enum('status', userStatus).notNullable().defaultTo(userStatus[0])
    table
      .string('role_id')
      .references('id')
      .inTable('roles')
      .onDelete('RESTRICT')
      .notNullable()
    table.string('deposit_image_url').nullable()
    table.timestamp('created_at').notNullable().defaultTo(knex.fn.now())
    table.timestamp('updated_at').notNullable().defaultTo(knex.fn.now())
  })
}

export async function down(knex: Knex): Promise<void> {
  await knex.schema.dropTable('users')
}



================================================
FILE: src/database/migrations/20250531163446_create_notifications_audit_related_table.ts
================================================
import { Knex } from 'knex'

export async function up(knex: Knex): Promise<void> {
  // Create audit_logs table for tracking all administrative actions
  await knex.schema.createTable('audit_logs', (table) => {
    table
      .string('id', 36)
      .primary()
      .defaultTo(knex.raw('gen_random_uuid()::varchar'))
    table
      .string('user_id', 36)
      .references('id')
      .inTable('users')
      .onDelete('SET NULL')
    table.string('action').notNullable()
    table.string('entity_type').notNullable()
    table.string('entity_id').notNullable()
    table.jsonb('old_values')
    table.jsonb('new_values')
    table.string('ip_address')
    table.string('user_agent')
    table.timestamp('created_at').notNullable().defaultTo(knex.fn.now())
  })

  // Create notification_types table
  await knex.schema.createTable('notification_types', (table) => {
    table
      .string('id', 36)
      .primary()
      .defaultTo(knex.raw('gen_random_uuid()::varchar'))
    table.string('name').notNullable().unique()
    table.text('description')
    table.text('template').notNullable()
    table.timestamp('created_at').notNullable().defaultTo(knex.fn.now())
    table.timestamp('updated_at').notNullable().defaultTo(knex.fn.now())
  })

  // Create notifications table
  await knex.schema.createTable('notifications', (table) => {
    table
      .string('id', 36)
      .primary()
      .defaultTo(knex.raw('gen_random_uuid()::varchar'))
    table
      .string('user_id', 36)
      .references('id')
      .inTable('users')
      .onDelete('CASCADE')
      .notNullable()
    table
      .string('notification_type_id', 36)
      .references('id')
      .inTable('notification_types')
      .onDelete('RESTRICT')
      .notNullable()
    table.string('title').notNullable()
    table.text('message').notNullable()
    table.jsonb('data')
    table.boolean('is_read').notNullable().defaultTo(false)
    table.timestamp('read_at')
    table.timestamp('created_at').notNullable().defaultTo(knex.fn.now())
    table.timestamp('updated_at').notNullable().defaultTo(knex.fn.now())
  })

  // Create email_logs table for tracking all sent emails
  await knex.schema.createTable('email_logs', (table) => {
    table
      .string('id', 36)
      .primary()
      .defaultTo(knex.raw('gen_random_uuid()::varchar'))
    table
      .string('user_id', 36)
      .references('id')
      .inTable('users')
      .onDelete('SET NULL')
    table.string('email').notNullable()
    table.string('subject').notNullable()
    table.text('body').notNullable()
    table.string('status').notNullable()
    table.text('error')
    table.timestamp('created_at').notNullable().defaultTo(knex.fn.now())
  })

  // Insert default notification types
  await knex('notification_types').insert([
    {
      name: 'account_approval',
      description: 'Account approval notification',
      template:
        'Your account has been approved. You can now access all features.'
    },
    {
      name: 'transaction_confirmation',
      description: 'Transaction confirmation notification',
      template: 'Your transaction of {{amount}} has been {{status}}.'
    },
    {
      name: 'loan_approval',
      description: 'Loan approval notification',
      template: 'Your loan application for {{amount}} has been {{status}}.'
    },
    {
      name: 'payment_reminder',
      description: 'Payment reminder notification',
      template:
        'Reminder: Your loan payment of {{amount}} is due on {{due_date}}.'
    },
    {
      name: 'late_payment',
      description: 'Late payment notification',
      template:
        'Your loan payment of {{amount}} was due on {{due_date}} and is now overdue.'
    }
  ])

  // Create indexes
  await knex.raw(
    'CREATE INDEX notifications_user_id_idx ON notifications (user_id)'
  )
  await knex.raw(
    'CREATE INDEX notifications_type_id_idx ON notifications (notification_type_id)'
  )
  await knex.raw(
    'CREATE INDEX notifications_unread_idx ON notifications (user_id) WHERE is_read = false'
  )
  await knex.raw('CREATE INDEX audit_logs_user_id_idx ON audit_logs (user_id)')
  await knex.raw('CREATE INDEX email_logs_user_id_idx ON email_logs (user_id)')
}

export async function down(knex: Knex): Promise<void> {
  await knex.raw('DROP INDEX IF EXISTS notifications_unread_idx')
  await knex.raw('DROP INDEX IF EXISTS notifications_user_id_idx')
  await knex.raw('DROP INDEX IF EXISTS notifications_type_id_idx')
  await knex.raw('DROP INDEX IF EXISTS audit_logs_user_id_idx')
  await knex.raw('DROP INDEX IF EXISTS email_logs_user_id_idx')

  await knex.schema.dropTable('email_logs')
  await knex.schema.dropTable('notifications')
  await knex.schema.dropTable('notification_types')
  await knex.schema.dropTable('audit_logs')
}



================================================
FILE: src/database/seeds/001_roles.ts
================================================
import { Knex } from 'knex'

export async function seed(knex: Knex): Promise<void> {
  await knex('roles').insert([
    {
      id: 'superadministrator',
      name: 'Super Administrator'
    },
    {
      id: 'administrator',
      name: 'Administrator'
    },
    {
      id: 'member',
      name: 'Member'
    }
  ])
}



================================================
FILE: src/database/seeds/002_admin_user.ts
================================================
import { Knex } from 'knex'
import { hash } from 'bcrypt'

export async function seed(knex: Knex): Promise<void> {
  const hashedPassword = await hash('admin123', 10)

  await knex('users').insert([
    {
      id: 'admin-001',
      email: 'admin@lumbungmesari.com',
      fullname: 'System Administrator',
      username: 'admin',
      password: hashedPassword,
      phone_number: '+62812345678',
      address: 'Lumbung Mesari Office',
      status: 'active',
      role_id: 'administrator',
      deposit_image_url: null
    }
  ])
}



================================================
FILE: src/database/types/audit.ts
================================================
export interface AuditLogTable {
  id: string
  user_id: string | null
  action: string
  entity_type: string
  entity_id: string
  old_values: unknown | null
  new_values: unknown | null
  ip_address: string | null
  user_agent: string | null
  created_at?: Date
}

export interface NotificationTypeTable {
  id: string
  name: string
  description: string | null
  template: string
  created_at?: Date
  updated_at?: Date
}

export interface NotificationTable {
  id: string
  user_id: string
  notification_type_id: string
  title: string
  message: string
  data: unknown | null
  read_at: Date | null
  created_at?: Date
  updated_at?: Date
}

export interface EmailLogTable {
  id: string
  user_id: string | null
  email: string
  subject: string
  template: string
  data: unknown | null
  status: string
  sent_at: Date | null
  error_message: string | null
  created_at?: Date
  updated_at?: Date
}

// Export types
export type AuditLog = AuditLogTable
export type NewAuditLog = Omit<AuditLogTable, 'id' | 'created_at'>
export type UpdateAuditLog = Partial<Omit<AuditLogTable, 'id' | 'created_at'>>

export type NotificationType = NotificationTypeTable
export type NewNotificationType = Omit<
  NotificationTypeTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateNotificationType = Partial<
  Omit<NotificationTypeTable, 'id' | 'created_at' | 'updated_at'>
>

export type Notification = NotificationTable
export type NewNotification = Omit<
  NotificationTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateNotification = Partial<
  Omit<NotificationTable, 'id' | 'created_at' | 'updated_at'>
>

export type EmailLog = EmailLogTable
export type NewEmailLog = Omit<
  EmailLogTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateEmailLog = Partial<
  Omit<EmailLogTable, 'id' | 'created_at' | 'updated_at'>
>



================================================
FILE: src/database/types/database.ts
================================================
import { UserTable } from './users'
import { RoleTable } from './roles'
import {
  SavingsAccountTable,
  TransactionTable,
  TransactionTypeTable
} from './savings'
import { LoanTable, LoanPeriodTable, InstallmentTable } from './loans'
import {
  AuditLogTable,
  NotificationTable,
  NotificationTypeTable,
  EmailLogTable
} from './audit'

export interface Database {
  // User management
  users: UserTable
  roles: RoleTable
  // Savings management
  savings_accounts: SavingsAccountTable
  transaction_types: TransactionTypeTable
  transactions: TransactionTable
  // Loan management
  loan_periods: LoanPeriodTable
  loans: LoanTable
  installments: InstallmentTable
  // Audit and notifications
  audit_logs: AuditLogTable
  notification_types: NotificationTypeTable
  notifications: NotificationTable
  email_logs: EmailLogTable
}



================================================
FILE: src/database/types/loans.ts
================================================
export interface LoanPeriodTable {
  id: string
  months: number
  interest_rate: string
  created_at?: Date
  updated_at?: Date
}

export interface LoanTable {
  id: string
  user_id: string
  loan_number: string
  amount: string
  loan_period_id: string
  interest_rate: string
  total_amount: string
  monthly_payment: string
  start_date: Date | null
  end_date: Date | null
  status: string
  approved_by: string | null
  approved_at: Date | null
  created_at?: Date
  updated_at?: Date
}

export interface InstallmentTable {
  id: string
  loan_id: string
  installment_number: number
  amount: string
  due_date: Date
  paid_date: Date | null
  paid_amount: string | null
  late_fee: string | null
  status: string
  created_at?: Date
  updated_at?: Date
}

// Export types
export type LoanPeriod = LoanPeriodTable
export type NewLoanPeriod = Omit<
  LoanPeriodTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateLoanPeriod = Partial<
  Omit<LoanPeriodTable, 'id' | 'created_at' | 'updated_at'>
>

export type Loan = LoanTable
export type NewLoan = Omit<LoanTable, 'id' | 'created_at' | 'updated_at'>
export type UpdateLoan = Partial<
  Omit<LoanTable, 'id' | 'created_at' | 'updated_at'>
>

export type Installment = InstallmentTable
export type NewInstallment = Omit<
  InstallmentTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateInstallment = Partial<
  Omit<InstallmentTable, 'id' | 'created_at' | 'updated_at'>
>



================================================
FILE: src/database/types/roles.ts
================================================
export interface RoleTable {
  id: string
  name: string
  created_at?: Date
  updated_at?: Date
}

export type Role = RoleTable
export type NewRole = Omit<RoleTable, 'id' | 'created_at' | 'updated_at'>
export type UpdateRole = Partial<
  Omit<RoleTable, 'id' | 'created_at' | 'updated_at'>
>



================================================
FILE: src/database/types/savings.ts
================================================
export interface SavingsAccountTable {
  id: string
  user_id: string
  account_number: string
  balance: string
  interest_rate: string
  status: string
  created_at?: Date
  updated_at?: Date
}

export interface TransactionTypeTable {
  id: string
  name: string
  description: string | null
  created_at?: Date
  updated_at?: Date
}

export interface TransactionTable {
  id: string
  user_id: string
  savings_account_id: string
  transaction_type_id: string
  amount: string
  balance_before: string
  balance_after: string
  description: string | null
  reference_number: string
  status: string
  processed_at: Date | null
  created_at?: Date
  updated_at?: Date
}

// Export types
export type SavingsAccount = SavingsAccountTable
export type NewSavingsAccount = Omit<
  SavingsAccountTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateSavingsAccount = Partial<
  Omit<SavingsAccountTable, 'id' | 'created_at' | 'updated_at'>
>

export type TransactionType = TransactionTypeTable
export type NewTransactionType = Omit<
  TransactionTypeTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateTransactionType = Partial<
  Omit<TransactionTypeTable, 'id' | 'created_at' | 'updated_at'>
>

export type Transaction = TransactionTable
export type NewTransaction = Omit<
  TransactionTable,
  'id' | 'created_at' | 'updated_at'
>
export type UpdateTransaction = Partial<
  Omit<TransactionTable, 'id' | 'created_at' | 'updated_at'>
>



================================================
FILE: src/database/types/users.ts
================================================
export interface UserTable {
  id: string
  email: string
  fullname: string
  username: string
  password: string
  phone_number: string
  address: string
  status: string
  role_id: string
  deposit_image_url?: string
  created_at?: Date
  updated_at?: Date
}

export type User = UserTable
export type NewUser = Omit<UserTable, 'id' | 'created_at' | 'updated_at'>
export type UpdateUser = Partial<
  Omit<UserTable, 'id' | 'created_at' | 'updated_at'>
>



================================================
FILE: src/interface/jwt.ts
================================================
export interface JwtPayload {
  sub: string
  email: string
  role: string
}



================================================
FILE: src/interface/users.ts
================================================
export type User = {
  id: string
  email: string
  fullname: string
  username: string
  password: string
  phone_number: string
  address: string
  status: string
  role_id: string
  deposit_image_url: string
  created_at: Date
  updated_at: Date
}



================================================
FILE: src/users/users.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing'
import { UsersController } from './users.controller'
import { UsersService } from './users.service'

describe('UsersController', () => {
  let controller: UsersController

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [UsersController],
      providers: [UsersService]
    }).compile()

    controller = module.get<UsersController>(UsersController)
  })

  it('should be defined', () => {
    expect(controller).toBeDefined()
  })

  it('should return all users', async () => {
    const result = await controller.findAll()
    expect(result).toBe('Hello World')
  })
})



================================================
FILE: src/users/users.controller.ts
================================================
import { Controller, Get } from '@nestjs/common'
import { UsersService } from './users.service'

@Controller('/users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  async findAll() {
    return this.usersService.findAll()
  }
}



================================================
FILE: src/users/users.module.ts
================================================
import { Module } from '@nestjs/common'
import { UsersController } from './users.controller'
import { UsersService } from './users.service'
import { UsersRepository } from './users.repository'
import { DatabaseModule } from '../database/database.module'

@Module({
  imports: [DatabaseModule],
  controllers: [UsersController],
  providers: [UsersService, UsersRepository],
  exports: [UsersService]
})
export class UsersModule {}



================================================
FILE: src/users/users.repository.ts
================================================
import { Injectable } from '@nestjs/common'
import { BaseRepository } from '../database/base.repository'
import { DatabaseService } from '../database/database.service'
import { User, NewUser, UpdateUser } from '../database/types/users'

@Injectable()
export class UsersRepository extends BaseRepository<User> {
  constructor(protected readonly databaseService: DatabaseService) {
    super(databaseService, 'users')
  }

  async findByEmail(email: string): Promise<User | undefined> {
    const result = await this.knex('users').where('email', email).first()

    return result as User | undefined
  }

  async findByEmailWithRole(
    email: string
  ): Promise<(User & { role_name: string }) | undefined> {
    const result = await this.knex('users')
      .join('roles', 'roles.id', 'users.role_id')
      .select([
        'users.id',
        'users.email',
        'users.fullname',
        'users.username',
        'users.password',
        'users.phone_number',
        'users.address',
        'users.status',
        'users.role_id',
        'users.deposit_image_url',
        'users.created_at',
        'users.updated_at',
        'roles.id as role'
      ])
      .where('users.email', email)
      .first()

    return result as (User & { role_name: string }) | undefined
  }

  async findByUsernameWithRole(
    username: string
  ): Promise<(User & { role_name: string }) | undefined> {
    const result = await this.knex('users')
      .join('roles', 'roles.id', 'users.role_id')
      .select([
        'users.id',
        'users.email',
        'users.fullname',
        'users.username',
        'users.password',
        'users.phone_number',
        'users.address',
        'users.status',
        'users.role_id',
        'users.deposit_image_url',
        'users.created_at',
        'users.updated_at',
        'roles.id as role'
      ])
      .where('users.username', username)
      .first()

    return result as (User & { role_name: string }) | undefined
  }

  async findByIdentifierWithRole(
    identifier: string
  ): Promise<(User & { role_name: string }) | undefined> {
    const result = await this.knex('users')
      .join('roles', 'roles.id', 'users.role_id')
      .select([
        'users.id',
        'users.email',
        'users.fullname',
        'users.username',
        'users.password',
        'users.phone_number',
        'users.address',
        'users.status',
        'users.role_id',
        'users.deposit_image_url',
        'users.created_at',
        'users.updated_at',
        'roles.id as role'
      ])
      .where('users.email', identifier)
      .orWhere('users.username', identifier)
      .first()

    return result as (User & { role_name: string }) | undefined
  }

  async findByUsername(username: string): Promise<User | undefined> {
    const result = await this.knex('users').where('username', username).first()

    return result as User | undefined
  }

  async findAllWithRoles(
    page = 1,
    limit = 10
  ): Promise<{
    data: (User & { role_name: string })[]
    total: number
    page: number
    limit: number
  }> {
    const offset = (page - 1) * limit

    // Get total count
    const [{ count }] = await this.knex('users').count('id as count')

    // Get users with role information
    const data = await this.knex('users')
      .join('roles', 'roles.id', 'users.role_id')
      .select([
        'users.id',
        'users.email',
        'users.fullname',
        'users.username',
        'users.phone_number',
        'users.address',
        'users.status',
        'users.role_id',
        'users.deposit_image_url',
        'users.created_at',
        'users.updated_at',
        'roles.name as role_name'
      ])
      .limit(limit)
      .offset(offset)

    return {
      data: data as (User & { role_name: string })[],
      total: Number(count),
      page,
      limit
    }
  }

  async createUser(data: NewUser): Promise<User> {
    return this.create(data as User)
  }

  async updateUser(id: string, data: UpdateUser): Promise<User> {
    return this.updateById(id, data as User)
  }

  async updateStatus(id: string, status: string): Promise<User> {
    return this.updateById(id, { status } as any)
  }
}



================================================
FILE: src/users/users.service.ts
================================================
import { Injectable, ConflictException } from '@nestjs/common'
import { NewUser } from '../database/types/users'
import { UsersRepository } from './users.repository'

@Injectable()
export class UsersService {
  constructor(private usersRepository: UsersRepository) {}

  async findByEmail(email: string) {
    return await this.usersRepository.findByEmail(email)
  }

  async findByEmailWithRole(email: string) {
    return await this.usersRepository.findByEmailWithRole(email)
  }

  async findByIdentifierWithRole(identifier: string) {
    return await this.usersRepository.findByIdentifierWithRole(identifier)
  }

  async create(userData: NewUser) {
    const existingUser = await this.findByEmail(userData.email)
    if (existingUser) {
      throw new ConflictException('Email already exists')
    }

    return await this.usersRepository.create(userData)
  }

  async findAll() {
    return await this.usersRepository.findAll()
  }
}


